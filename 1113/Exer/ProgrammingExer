Q1. [Display ASCII Decimal]
Write a procedure named WriteScaled that outputs a decimal ASCII number with an implied decimal point. Suppose the following number were defined as follows, where DECIMAL_OFFSET
indicates that the decimal point must be inserted five positions from the right side of the number:
DECIMAL_OFFSET = 5
.data
decimal_one BYTE "100123456789765"
WriteScaled would display the number like this:
1001234567.89765
When calling WriteScaled, pass the number’s offset in EDX, the number length in ECX, and the
decimal offset in EBX. Write a test program that passes three numbers of different sizes to the
WriteScaled procedure.
- (해석) -
WriteScaled라는 프로시저를 작성하여, ASCII 숫자 문자열을 출력할 때 소수점을 지정된 위치(DECIMAL_OFFSET)에서 삽입하도록 하라.
예시:
  문자열 "100123456789765"
  DECIMAL_OFFSET = 5 → 오른쪽에서 다섯 자리에서 소수점 삽입
  출력: "1001234567.89765"
프로시저 호출 규칙:
  EDX = 숫자 문자열 시작 주소
  ECX = 문자열 길이
  EBX = 소수점 위치 (오른쪽에서부터)
또한, 테스트 프로그램에서 서로 다른 길이의 3개 숫자를 프로시저에 전달해 출력

------------------------------------------------------[Q1.code]-------------------------------------------------------------------------------------------------------

;----------------------------------------
; WriteScaled: ASCII 숫자 문자열에 소수점 삽입 후 출력
; 입력:
;   EDX = 문자열 시작 주소
;   ECX = 문자열 길이
;   EBX = 소수점 위치 (오른쪽에서부터)
;----------------------------------------
WriteScaled PROC
    push edx
    push ecx
    push ebx

    mov esi, edx        ; ESI = 현재 문자 포인터
    mov edi, ecx        ; EDI = 전체 길이
    mov eax, ebx        ; EAX = 소수점 위치

PrintLoop:
    mov al, [esi]       ; 현재 문자 가져오기
    call WriteChar      ; 출력

    dec edi             ; 남은 문자 수 감소
    inc esi             ; 다음 문자로 이동

    cmp edi, eax        ; 소수점 위치 도달?
    jne ContinueLoop
    mov al, '.'         ; 소수점 출력
    call WriteChar

ContinueLoop:
    cmp edi, 0
    jne PrintLoop

    pop ebx
    pop ecx
    pop edx
    ret
WriteScaled ENDP

;----------------------------------------
; 테스트 프로그램
;----------------------------------------
.data
decimal1 BYTE "100123456789765"
decimal2 BYTE "987654321"
decimal3 BYTE "12345"
DECIMAL_OFFSET1 = 5
DECIMAL_OFFSET2 = 3
DECIMAL_OFFSET3 = 2

.code
start:
    ; decimal1 출력
    mov edx, OFFSET decimal1
    mov ecx, LENGTHOF decimal1
    mov ebx, DECIMAL_OFFSET1
    call WriteScaled

    ; 줄바꿈
    mov al, 0Ah
    call WriteChar

    ; decimal2 출력
    mov edx, OFFSET decimal2
    mov ecx, LENGTHOF decimal2
    mov ebx, DECIMAL_OFFSET2
    call WriteScaled

    ; 줄바꿈
    mov al, 0Ah
    call WriteChar

    ; decimal3 출력
    mov edx, OFFSET decimal3
    mov ecx, LENGTHOF decimal3
    mov ebx, DECIMAL_OFFSET3
    call WriteScaled

    ; 프로그램 종료
    ret
설명

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q2. [Extended Subtraction Procedure]
Create a procedure named Extended_Sub that subtracts two binary integers of arbitrary size. The storage size of the two integers must be the same,
and their size must be a multiple of 32 bits. Write a test program that passes several pairs of integers, each at least 10 bytes long.
- (해석) -
Extended_Sub라는 프로시저를 작성하여, 임의 크기(arbitrary size)의 2진 정수를 뺄셈하도록 하라. 두 정수의 크기는 같아야 하고, 32비트 단위로 나누어 떨어져야 한다.
테스트 프로그램에서는 10바이트 이상인 여러 정수 쌍을 프로시저에 전달하여 뺄셈 결과를 확인한다.

------------------------------------------------------[Q2.code]-------------------------------------------------------------------------------------------------------

;----------------------------------------
; Extended_Sub: 임의 크기 이진 정수 뺄셈
; ESI = minuend(피감수) 주소
; EDI = subtrahend(감수) 주소
; ECX = DWORD 단위 개수
; 결과는 피감수(EAX 배열)에 저장
;----------------------------------------
Extended_Sub PROC
    push ebx
    xor ebx, ebx       ; EBX = borrow (0)

SubLoop:
    mov eax, [esi]     ; 피감수 32비트 로드
    mov edx, [edi]     ; 감수 32비트 로드
    sbb eax, edx       ; 이전 borrow 포함 뺄셈
    sbb eax, ebx       ; EBX(이전 borrow) 적용
    mov [esi], eax     ; 결과 저장

    ; borrow 계산: 만약 현재 뺄셈에서 빌림 발생 시 EBX = 1, 아니면 0
    mov ebx, 0
    mov eax, [esi]
    mov edx, [edi]
    cmp eax, edx
    jae NoBorrow
    mov ebx, 1
NoBorrow:

    add esi, 4
    add edi, 4
    loop SubLoop

    pop ebx
    ret
Extended_Sub ENDP

-test 프로그램 -
.data
num1 DWORD 0x12345678, 0x9ABCDEF0, 0x11111111
num2 DWORD 0x11111111, 0x11111111, 0x11111111

.code
start:
    mov esi, OFFSET num1
    mov edi, OFFSET num2
    mov ecx, 3       ; DWORD 단위 개수
    call Extended_Sub

    ; 결과 출력 또는 디버깅용 브레이크포인트
    ret

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q3. [Packed Decimal Conversion]
Write a procedure named PackedToAsc that converts a 4-byte packed decimal integer to a string of ASCII decimal digits. Pass the packed integer 
and the address of a buffer holding the ASCII digits to the procedure. Write a short test program that passes at least 5 packed decimal integers
to your procedure.
- (해석) -
PackedToAsc라는 프로시저를 작성하여, 4바이트 packed decimal 정수를 ASCII 문자열로 변환하라.
입력:
  packed decimal 값 (4바이트)
  ASCII 결과를 저장할 버퍼 주소
테스트 프로그램에서는 최소 5개의 packed decimal 정수를 프로시저에 전달하고 변환 결과를 확인

------------------------------------------------------[Q3.code]-------------------------------------------------------------------------------------------------------

;----------------------------------------
; PackedToAsc: 4-byte packed decimal → ASCII
; EAX = packed decimal 값
; EDX = 버퍼 주소
;----------------------------------------
PackedToAsc PROC
    push ebx
    push ecx

    mov ecx, 4        ; 4바이트 처리
    mov ebx, edx      ; EBX = 버퍼 포인터

PackedLoop:
    mov al, al        ; 현재 바이트 준비
    mov ah, al
    and al, 0Fh       ; 하위 nibble
    add al, '0'
    mov [ebx], al
    inc ebx

    mov al, ah
    shr al, 4         ; 상위 nibble
    add al, '0'
    mov [ebx], al
    inc ebx

    ; 다음 바이트로 이동
    ; EAX에서 다음 바이트 처리
    shr eax, 8
    loop PackedLoop

    pop ecx
    pop ebx
    ret
PackedToAsc ENDP

-test 프로그램 -
.data
packedNums DWORD 0x12345678, 0x87654321, 0x11111111, 0x99999999, 0x0A0B0C0D
asciiBuffer BYTE 16 DUP(0)

.code
start:
    mov esi, OFFSET packedNums
    mov edi, OFFSET asciiBuffer
    mov ecx, 5           ; 5개의 packed decimal

TestLoop:
    mov eax, [esi]       ; packed decimal 로드
    mov edx, edi         ; 버퍼 주소
    call PackedToAsc

    add esi, 4           ; 다음 packed decimal
    add edi, 8           ; 버퍼 이동 (4바이트 → 8자리 ASCII)
    loop TestLoop

    ret

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q4. [Encryption Using Rotate Operations]
Write a procedure that performs simple encryption by rotating each plaintext byte a varying number of positions in different directions. 
For example, in the following array that represents the encryption key, a negative value indicates a rotation to the left and a positive 
value indicates a rotation to the right. The integer in each position indicates the magnitude of the rotation:
key BYTE -2, 4, 1, 0, -3, 5, 2, -4, -4, 6 Your procedure should loop through a plaintext message and align the key to the first 10 bytes of
the message. Rotate each plaintext byte by the amount indicated by its matching key array value. Then, align the key to the next 10 bytes of 
the message and repeat the process. Write a program that tests your encryption procedure by calling it twice, with different data sets.
- (해석) -
목표: 각 평문 바이트를 **다양한 위치로 회전(rotate)**시켜 암호화하는 프로시저 작성
키 배열:
  음수 → 왼쪽으로 회전 
  양수 → 오른쪽으로 회전
  0 → 회전 없음
예: 
  key BYTE -2, 4, 1, 0, -3, 5, 2, -4, -4, 6
처리 방법:
  메시지를 10바이트 단위로 나눔 
  각 10바이트에 대해 키 배열을 적용
  다음 10바이트에도 반복
테스트:
  서로 다른 데이터 세트 두 개를 프로시저에 전달하여 실행

------------------------------------------------------[Q4.code]-------------------------------------------------------------------------------------------------------

.data
; 암호화 키: -2, 4, 1, 0, -3, 5, 2, -4, -4, 6
key BYTE 0xFE, 4, 1, 0, 0xFD, 5, 2, 0xFC, 0xFC, 6

; 테스트 메시지
msg1 BYTE "HELLOWORLD1234567890", 0
msg2 BYTE "ASSEMBLYCRYPT", 0

.code

;----------------------------------------
; Encrypt: 메시지 바이트를 키 기반으로 회전
; ESI = 메시지 시작 주소
; ECX = 메시지 길이
;----------------------------------------
Encrypt PROC
    push esi
    push ecx
    push edx
    push ebx

    mov ebx, 0          ; 키 인덱스 초기화

EncryptLoop:
    mov al, [esi]       ; 현재 평문 바이트 로드
    mov dl, [key + ebx] ; 키 값 로드

    cmp dl, 0
    je NoRotate         ; 0이면 회전 없음

    cmp dl, 0
    jl RotateLeft       ; 음수 → 왼쪽 회전

    ; 양수 → 오른쪽 회전
    mov cl, dl
    ror al, cl
    jmp StoreByte

RotateLeft:
    neg dl
    mov cl, dl
    rol al, cl
    jmp StoreByte

NoRotate:
    ; al 그대로
StoreByte:
    mov [esi], al       ; 암호화된 바이트 저장

    inc esi
    inc ebx
    cmp ebx, 10
    jl NextByte
    mov ebx, 0          ; 키 재사용
NextByte:
    loop EncryptLoop

    pop ebx
    pop edx
    pop ecx
    pop esi
    ret
Encrypt ENDP

;----------------------------------------
; 테스트 프로그램
;----------------------------------------
start:
    ; msg1 암호화
    mov esi, OFFSET msg1
    mov ecx, 20         ; 길이
    call Encrypt

    ; msg2 암호화
    mov esi, OFFSET msg2
    mov ecx, 13         ; 길이
    call Encrypt

    ret

- test프로그램 -
start:
    ; === msg1 테스트 ===
    mov esi, OFFSET msg1
    call WriteString       ; 암호화 전 출력
    mov al, 0Ah
    call WriteChar

    mov esi, OFFSET msg1
    mov ecx, 20
    call Encrypt           ; msg1 암호화

    mov esi, OFFSET msg1
    call WriteString       ; 암호화 후 출력
    mov al, 0Ah
    call WriteChar

    ; === msg2 테스트 ===
    mov esi, OFFSET msg2
    call WriteString       ; 암호화 전 출력
    mov al, 0Ah
    call WriteChar

    mov esi, OFFSET msg2
    mov ecx, 13
    call Encrypt           ; msg2 암호화

    mov esi, OFFSET msg2
    call WriteString       ; 암호화 후 출력
    mov al, 0Ah
    call WriteChar

    ret

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q5. [Prime Numbers]
Write a program that generates all prime numbers between 2 and 1000, using the Sieve of Eratosthenes method. You can find many articles that describe 
the method for finding primes in this manner on the Internet. Display all the prime values.
- (해석) -
2부터 1000까지의 모든 소수(prime number)를 생성하는 프로그램 작성을 할 떄 에라토스테네스의 체(Sieve of Eratosthenes) 방법 사용을 하여 결과를 출력

------------------------------------------------------[Q5.code]-------------------------------------------------------------------------------------------------------

.data
; 2~1000까지 소수 표시용 배열 (0=소수 아님, 1=소수)
; 배열 인덱스 = 숫자
primeFlags BYTE 1001 DUP(1)   ; 0~1000 (primeFlags[0], primeFlags[1] 사용 안함)
newline BYTE 0Ah, 0

.code
start:
    ; 0과 1은 소수가 아니므로 0으로 표시
    mov byte ptr [primeFlags+0], 0
    mov byte ptr [primeFlags+1], 0

    ; i = 2 ~ sqrt(1000) 반복 (약 31)
    mov ecx, 32
    mov ebx, 2
SieveOuter:
    mov al, [primeFlags+ebx]
    cmp al, 0
    je SkipOuter
    ; ebx가 소수이면, 그 배수들을 제거
    mov esi, ebx
    imul esi, 2       ; 시작 배수 = 2*ebx
SieveInner:
    cmp esi, 1000
    ja InnerDone
    mov byte ptr [primeFlags+esi], 0
    add esi, ebx
    jmp SieveInner
InnerDone:
SkipOuter:
    inc ebx
    loop SieveOuter

    ; 2~1000까지 소수 출력
    mov ebx, 2
PrintLoop:
    cmp ebx, 1001
    je Done
    mov al, [primeFlags+ebx]
    cmp al, 0
    je SkipPrint
    ; ebx 출력 (숫자 출력 함수 필요)
    push ebx
    call PrintNumber
    call PrintNewline
    pop ebx
SkipPrint:
    inc ebx
    jmp PrintLoop

Done:
    ret

;----------------------------------------
; PrintNumber: EBX 숫자를 10진수 ASCII로 출력
; 임시 EAX, ECX, EDX 사용
;----------------------------------------
PrintNumber PROC
    push eax
    push ecx
    push edx

    mov eax, ebx
    mov ecx, 0

    ; 숫자를 역순으로 버퍼에 저장
    mov edi, OFFSET numBuffer
ConvLoop:
    xor edx, edx
    mov ebx, 10
    div ebx            ; EAX / 10, remainder in EDX
    add dl, '0'
    mov [edi+ecx], dl
    inc ecx
    test eax, eax
    jnz ConvLoop

    ; 버퍼를 역순으로 출력
    dec ecx
PrintDigits:
    mov al, [edi+ecx]
    call WriteChar
    dec ecx
    jns PrintDigits

    pop edx
    pop ecx
    pop eax
    ret
PrintNumber ENDP

PrintNewline PROC
    mov al, 0Ah
    call WriteChar
    ret
PrintNewline ENDP

.data
numBuffer BYTE 10 DUP(0)

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q6. [Greatest Common Divisor (GCD)]
The greatest common divisor (GCD) of two integers is the largest integer that will evenly divide
both integers. The GCD algorithm involves integer division in a loop, described by the following
pseudocode:
int GCD(int x, int y)
{
x = abs(x) // absolute value
y = abs(y)
do {
int n = x % y
x = y
y = n
} while (y > 0)
return x
}
Implement this function in assembly language and write a test program that calls the function
several times, passing it different values. Display all results on the screen.
- (해석) -
최대공약수(GCD) 정의:
  두 정수의 최대공약수는 두 정수를 모두 나눌 수 있는 가장 큰 정수입니다.
알고리즘 설명:
  주어진 의사코드를 보면, **유클리드 호제법(Euclidean algorithm)**을 사용합니다.
  x와 y를 절댓값으로 변환한 뒤, 다음 과정을 반복합니다:
  n = x % y (x를 y로 나눈 나머지)
  x = y
  y = n
  y가 0보다 클 동안 반복
  반복 종료 후 x가 최대공약수
어셈블리 구현 요구:
  위 GCD 함수를 어셈블리어로 작성
테스트 프로그램 작성:
  여러 번 GCD 함수를 호출
  다양한 값들을 전달
  결과를 화면에 출력

------------------------------------------------------[Q6.code]-------------------------------------------------------------------------------------------------------

.data
newline BYTE 0Ah,0           ; 줄바꿈
testPairs DWORD 15,25, 100,80, 21,14, 270,192, 48,180 ; 테스트할 x,y 쌍
numBuffer BYTE 12 DUP(0)     ; 숫자 변환용 버퍼

.code

;----------------------------------------
; GCD 함수: EAX = x, EBX = y
; 결과 반환: EAX
;----------------------------------------
GCD PROC
    push ecx
    push edx

    ; 절대값 처리
    cmp eax,0
    jge AbsXDone
    neg eax
AbsXDone:
    cmp ebx,0
    jge AbsYDone
    neg ebx
AbsYDone:

GCDLoop:
    cmp ebx,0
    je GCDDone

    ; 나머지 계산: EAX % EBX
    mov edx,0
    div ebx          ; EAX / EBX -> quotient in EAX, remainder in EDX

    ; x = y, y = 나머지
    mov eax, ebx
    mov ebx, edx
    jmp GCDLoop

GCDDone:
    ; 결과는 EAX
    pop edx
    pop ecx
    ret
GCD ENDP

;----------------------------------------
; 숫자를 ASCII로 변환 후 출력
; EBX = 숫자
;----------------------------------------
PrintNumber PROC
    push eax
    push ecx
    push edx

    mov eax, ebx
    mov ecx,0
    mov edi, OFFSET numBuffer

ConvLoop:
    xor edx, edx
    mov ebx,10
    div ebx
    add dl,'0'
    mov [edi+ecx], dl
    inc ecx
    test eax,eax
    jnz ConvLoop

    ; 역순으로 출력
    dec ecx
PrintLoop:
    mov al,[edi+ecx]
    call WriteChar
    dec ecx
    jns PrintLoop

    pop edx
    pop ecx
    pop eax
    ret
PrintNumber ENDP

PrintNewline PROC
    mov al,0Ah
    call WriteChar
    ret
PrintNewline ENDP

- test프로그램 -
start:
    mov esi, OFFSET testPairs
    mov ecx,5         ; 5쌍 테스트

TestLoop:
    mov eax,[esi]     ; x
    mov ebx,[esi+4]   ; y
    call GCD          ; GCD 계산 -> EAX

    mov ebx,eax
    call PrintNumber
    call PrintNewline

    add esi,8         ; 다음 쌍
    loop TestLoop

    ret

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q7. [Bitwise Multiplication]
Write a procedure named BitwiseMultiply that multiplies any unsigned 32-bit integer by EAX, using only shifting and addition. Pass the integer to the procedure in the EBX register,
and return the product in the EAX register. Write a short test program that calls the procedure and displays the product. (We will assume that the product is never larger than 32 bits.) 
This is a fairly challenging program to write. One possible approach is to use a loop to shift the multiplier to the right, keeping track of the number of shifts that occur before the 
Carry flag is set. The resulting shift count can then be applied to the SHL instruction, using the multiplicand as the destination operand. Then, the same process must be repeated until 
you find the last 1 bit in the multiplier.
- (해석) -
목표:
  EAX에 있는 값을 EBX에 있는 32비트 정수와 곱함
  단, 곱셈 명령어(MUL, IMUL) 금지
  시프트(SHL/SHR)와 덧셈(ADD)만 사용
입력/출력:
  EBX = 곱할 값 (multiplier)
  EAX = 곱해질 값 (multiplicand)
  결과 = EAX
방법 힌트:
  multiplier(EBX)를 오른쪽으로 시프트하면서, Carry가 설정될 때까지 몇 번 시프트했는지 카운트
  시프트 카운트를 multiplicand(EAX)에 SHL 적용
  마지막 1비트를 찾을 때까지 반복
  각 단계에서 덧셈을 이용하여 최종 곱 계산

------------------------------------------------------[Q7.code]-------------------------------------------------------------------------------------------------------

.data
newline BYTE 0Ah,0
testPairs DWORD 7,5, 10,12, 15,3, 123,45 ; 테스트용 multiplicand, multiplier 쌍
numBuffer BYTE 12 DUP(0) ; 숫자 출력용 버퍼

.code

;----------------------------------------
; BitwiseMultiply
; EAX = multiplicand
; EBX = multiplier
; 결과 = EAX
;----------------------------------------
BitwiseMultiply PROC
    push ecx
    push edx
    push esi

    xor esi, esi      ; ESI = product 초기화
    mov ecx, 32       ; 32비트 반복

MulLoop:
    test bl,1         ; multiplier의 최하위 비트 확인
    jz SkipAdd
    add esi,eax       ; 해당 비트가 1이면 multiplicand 더함
SkipAdd:
    shl eax,1         ; multiplicand << 1
    shr ebx,1         ; multiplier >> 1
    loop MulLoop

    mov eax,esi       ; 결과를 EAX로
    pop esi
    pop edx
    pop ecx
    ret
BitwiseMultiply ENDP

;----------------------------------------
; 숫자를 ASCII로 변환 후 출력
; EBX = 숫자
;----------------------------------------
PrintNumber PROC
    push eax
    push ecx
    push edx

    mov eax, ebx
    mov ecx,0
    mov edi, OFFSET numBuffer

ConvLoop:
    xor edx, edx
    mov ebx,10
    div ebx
    add dl,'0'
    mov [edi+ecx], dl
    inc ecx
    test eax,eax
    jnz ConvLoop

    dec ecx
PrintLoop:
    mov al,[edi+ecx]
    call WriteChar
    dec ecx
    jns PrintLoop

    pop edx
    pop ecx
    pop eax
    ret
PrintNumber ENDP

PrintNewline PROC
    mov al,0Ah
    call WriteChar
    ret
PrintNewline ENDP

- test프로그램 -
start:
    mov esi, OFFSET testPairs
    mov ecx,4         ; 4쌍 테스트

TestLoop:
    mov eax,[esi]     ; multiplicand
    mov ebx,[esi+4]   ; multiplier
    call BitwiseMultiply ; EAX = 결과

    mov ebx,eax
    call PrintNumber
    call PrintNewline

    add esi,8
    loop TestLoop

    ret

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q8. [Add Packed Integers]
Extend the AddPacked procedure from Section 7.6.1 so that it adds two packed decimal integers of arbitrary size (both lengths must be the same). Write a test program that passes
AddPacked several pairs of integers: 4-byte, 8-byte, and 16-byte. We suggest that you use the
following registers to pass information to the procedure:
ESI - pointer to the first number
EDI - pointer to the second number
EDX - pointer to the sum
ECX - number of bytes to add
- (해석) -
목표:
  두 개의 packed decimal 숫자를 더해서 결과를 저장
  길이는 동일해야 하며, 임의 길이 가능 (예: 4, 8, 16바이트)
입력:
  ESI → 첫 번째 숫자
  EDI → 두 번째 숫자
  EDX → 결과를 저장할 주소
  ECX → 바이트 수
알고리즘:
  배열 끝에서부터 시작 (LSB 쪽)
  각 바이트 단위로 ADD + ADC
  마지막에 CARRY 처리

------------------------------------------------------[Q8.code]-------------------------------------------------------------------------------------------------------

.data
num1_4 BYTE 12h,34h,56h,78h        ; 4-byte packed decimal
num2_4 BYTE 87h,65h,43h,21h

num1_8 BYTE 12h,34h,56h,78h,90h,12h,34h,56h
num2_8 BYTE 65h,43h,21h,09h,87h,65h,43h,21h

num1_16 BYTE 10h,20h,30h,40h,50h,60h,70h,80h,90h,01h,12h,23h,34h,45h,56h,67h
num2_16 BYTE 01h,12h,23h,34h,45h,56h,67h,78h,89h,90h,01h,12h,23h,34h,45h,56h

sum_4 BYTE 4 DUP(0)
sum_8 BYTE 8 DUP(0)
sum_16 BYTE 16 DUP(0)

.code

;----------------------------------------
; AddPacked: ESI=첫번째 숫자, EDI=두번째 숫자
; EDX=합 저장, ECX=바이트 수
;----------------------------------------
AddPacked PROC
    push eax
    push ebx
    push ecx
    push edx
    push esi
    push edi

    mov eax,0          ; 캐리 초기화
    mov ebx,ecx        ; 바이트 카운트 저장

    dec esi
    dec edi
    dec edx

AddLoop:
    mov al,[esi]
    add al,[edi]
    adc al,0           ; 이전 캐리 포함
    daa                ; BCD 조정
    mov [edx],al

    dec esi
    dec edi
    dec edx

    dec ebx
    jnz AddLoop

    pop edi
    pop esi
    pop edx
    pop ecx
    pop ebx
    pop eax
    ret
AddPacked ENDP

;----------------------------------------
; 숫자 출력 (16진수 바이트 단위)
;----------------------------------------
PrintPacked PROC
    push ecx
    push eax
    push ebx
    push edx
    push esi

    mov esi,edx        ; EDX = 배열 시작
PrintLoop:
    mov al,[esi]
    mov ah,al
    shr ah,4
    and al,0Fh
    call PrintNibble
    mov al,ah
    call PrintNibble
    inc esi
    loop PrintLoop

    pop esi
    pop edx
    pop ebx
    pop eax
    pop ecx
    ret
PrintPacked ENDP

PrintNibble PROC
    cmp al,9
    jbe Dig
    add al,'A'-10
    jmp ShortPrint
Dig:
    add al,'0'
ShortPrint:
    call WriteChar
    ret
PrintNibble ENDP

- test프로그램 -
start:
    ; 4-byte
    lea esi,num1_4
    lea edi,num2_4
    lea edx,sum_4
    mov ecx,4
    call AddPacked
    lea edx,sum_4
    mov ecx,4
    call PrintPacked
    call PrintNewline

    ; 8-byte
    lea esi,num1_8
    lea edi,num2_8
    lea edx,sum_8
    mov ecx,8
    call AddPacked
    lea edx,sum_8
    mov ecx,8
    call PrintPacked
    call PrintNewline

    ; 16-byte
    lea esi,num1_16
    lea edi,num2_16
    lea edx,sum_16
    mov ecx,16
    call AddPacked
    lea edx,sum_16
    mov ecx,16
    call PrintPacked
    call PrintNewline

    ret

----------------------------------------------------------------------------------------------------------------------------------------------------------------------







