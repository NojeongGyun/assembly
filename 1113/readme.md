<pre>
- <mark>Shift</mark> -
쉬프트연산은 그 비트들을 왼쪽 또는 오른쪽으로 한 칸씩 이동시키는 연산입니다.

<b>SHL(shift left)</b> -
목적 피연산자에 대해 논리적 왼쪽 시프트를 수행하며, 가장 낮은 비트는 0으로 채웁니다.
이떄 가장 높은 비트는 계속해서 밀리게 되고, 마지막 논리적 왼쪽 쉬프트를 하면 밀린 비트가 CF값이 됩니다.
ex) 10001 SHL(1번) -> 00010 (CF = 1) SHL(1번) -> 00100 (CF = 0)
  
<b>SHR(shift right)</b> -
목적 피연산자에 대해 논리적 오른쪽 시프트를 수행하며, 가장 높은 비트는 0으로 대체 됩니다.
이때 가장 낮은 비트는 계속해서 밀리게 되고, 마지막 논리적 오른쪽 쉬프트를 하면 밀린 비트가 CF값이 됩니다.
ex)  10001 SHL(1번) -> 01000 (CF = 1) SHL(1번) -> 00100 (CF = 0)

<b>SAL (shift arithmetic left)</b> -
산술 왼쪽 시프트는 SHL과 똑같은 기능을 수행합니다.
  
<b>SAR (shift arithmetic right)</b> -
목적 피연산자에 대해 산술적 오른쪽 시프트를 수행하며, 가장 높은 비트의 값으로 밀리게 되며, 가장 높은 비트는 변하지 않습니다.
마찬가지로 마지막 산술적 오른쪽 시프트로 밀린 비트가 CF값이 됩니다.
ex) 10001 SAR(1번) -> 11000 (CF = 1) SAR(1번) -> 11100 (CF = 0)

<b>ROL(rotate left)</b> -
모든 비트를 왼쪽으로 이동시키며, 최상위 비트는 Carry 플래그와 최하위 비트 자리(LSB 자리)에 복사됩니다.
ex) 10001 ROL(1번) -> 00011 (CF = 1) ROL(1번) -> 00110 (CF = 0)

<b>ROR(rotate right)</b> -
모든 비트를 오른쪽으로 이동시키며, 최하위 비트(LSB)를 Carry 플래그와 최상위 비트 자리(MSB 자리)에 합니다.
ex) 10001 ROR(1번) -> 11000 (CF = 1) ROR(1번) -> 01100 (CF = 0)

<b>RCL(rotate carry left)</b> -
모든 비트를 왼쪽으로 이동시키고, Carry 플래그 값을 최하위 비트(LSB)에 복사하며, 최상위 비트(MSB)를 Carry 플래그로 복사합니다.
ex) 10001 (CF = 0) RCL(1번) -> 00010 (CF = 1) RCL(1번) -> 00101 (CF = 0)

<b>RCR(rotate carry right)</b> -
모든 비트를 오른쪽으로 이동시키고, Carry 플래그 값을 최상위 비트(MSB)에 복사하며, 최하위 비트(LSB)를 Carry 플래그로 복사합니다.
ex) 10001 (CF = 0) RCR(1번) -> 01000 (CF = 1) RCR(1번) -> 10100 (CF = 0)

<b>SHLD(Shift Left Double)</b>
목적지 오퍼랜드를 지정한 비트 수만큼 왼쪽으로 이동시키는 명령어입니다. 
이때 지정할 비트를 소스 오퍼랜드를 쓰는데, 소스 오퍼랜드의 MSB가 오른쪽에서 계속 채워집니다.
ex) * source : 01110    10001 SHLD(1번) -> 00010 (CF = 1) SHLD(1번) -> 00100 (CF = 0)   
    * source : 11110    10001 SHLD(1번) -> 00011 (CF = 1) SHLD(1번) -> 00111 (CF = 0)

<b>SHRD(shift right double)</b>
목적지 오퍼랜드를 지정한 비트 수만큼 오른쪽으로 이동시키는 명령어입니다. 
이때 지정할 비트를 소스 오퍼랜드를 쓰는데, 소스 오퍼랜드의 LSB가 왼쪽에서 계속 채워집니다.
ex) * source : 01110    10001 SHRD(1번) -> 01000 (CF = 1) SHLD(1번) -> 00100 (CF = 0)
    * source : 01111    10001 SHRD(1번) -> 11000 (CF = 1) SHLD(1번) -> 11100 (CF = 0)

- <mark>mul, imul</mark> -
mul과 imul은 곱셈 명령어입니다. 다만 다른점은 signed 연산을 하냐 하지 않냐의 차이입니다.

<b>mul</b> -
mul명령어는 signed연산을 하지 않고, 곱 연산을 진행합니다.
2-operand 연산일 떄는 목적지 오퍼랜드와 소스 오퍼랜드를 곱하고, 목적지 오퍼랜드에 저장하는식이고,
3-operand 연산일 때는 소스 오퍼랜드 2개끼리 곱한 후 목적지 오퍼랜드에 저장이 됩니다.
하지만 1-operand 연산일떄는 오퍼랜드가 8/16/32 비트인경우 al/ax/eax 값과 곱한 후 ax/dx:ax/edx:eax 에 저장이 됩니다.
ex) mov al, 3   // mul연산일 떄 만약 -3을 넣으면 -3값이 아닌, 256 - 3 = 253 즉 253값으로 인식이 됩니다.
    mov bx, 10
    mul bx    // bx는 10이고 al은 3이므로 10 * 3 = 30 즉 ax에 30값이 저장이 됩니다.  
  
<b>imul</b>
mul명령어는 signed연산을 포함하여 곱 연산을 진행합니다.
1,2,3 - operand는 위에 설명한 것과 같습니다.
ex) mov al, -3   
    mov bx, 10
    imul bx    // imul은 signed연산을 하는 명령어이기에 al은 -3 그대로 들어오고, bx는 10이므로 10 * -3 = -30 즉 ax에 -30값이 저장이 됩니다.



























  
</pre>










6p
쉬프트를 통해서 곱셈을 더 빨리 할 수 있음
00000101(2진수) = 5   =>(왼쪽 쉬프트 1번) 00001010(2진수) = 5 * 2^1 = 10 
=>(왼쪽 쉬프트 2번) 5 * 2^2 = 20 
반대로 오른쪽 쉬프트를 하면 5 / 2 의 정수?

SHR은 부호를 지키지 않아 음수이면 부호를 바껴 원하는 값을 찾기 힘듬
SAR은 부호를 지키기 위해 MSB의 값을 다시 제값을 찾고, 오른쯕으로 쉬프트 됩니다.

p10
ROl명령어는 왼쪽 쉬프트를 하면 MSB가 CF에 들어가게 되는데, 그 후 MSB는 LSB에 값이 들어갑니다.
밑에 예시에 보면 16진수이면 4개의 2진수 비트가 1개로 묶여있기 때문에 ROL 4번을 하면 16진수 1개의 비트값이 오른쪽에 들어갑니다.




p25
8비트의 mul이 나오면 16비트 레지스터로 저장
mul은 8비트이면 무조권 al의 값을 곱함(묵시적임) -> 이게 명령어가 1개 나온 기준임
결과는 AX에 저장됨
Carry flag에도 연관됨
mul이란 명령은 오퍼랜드 1개만 사용할 때만 쓸수 있음

imul은 오퍼랜드 2개 이상일 때만 사용할 수 있음
목적지오퍼랜드, 소스오퍼랜드, 



p34
div는 반대로 al로 나누고, ah에 저장합니다.

p35
몫은 AX, 나머지는 DX에 들어간다.

p37
cwd - 부호 확장 명령어(SiGN비트가 어떤 숫자에 따라서 부호 확장할때, 1로 채우는지, 0으로 채우는지 결정된다.)

p40
나누기를 하면 플래그 레지스터는 바뀌지 않는다.

p41
div b1을 하면 ax / b1을 하여 ah에 몫, al에 나머지가 저장이 되는데, 나머지에서 al의 비트가 표현할 수 있는 정수의 한도보다 더 채워졌기에 오버플로우가 발생 합니다.

p42
je - 나누기를 할때 0을 나누기 하면 컴퓨터적 오류가 나기에 먼저 je명령어로 0으로 나누는게 아닌지 판단 하고, 여부에 따라 진행 합니다.

p47
ADC명령어 - ??

p48
SBB - 자리 빌림
최상위 비트에서 캐리가 발생하거나, 자리 빌림이 발생하면, 1로 세팅되는게 캐리 플래그입니다. 그럴경우에 carry flag로 같이 연산에 포함하세요 라는게 SBB입니다.

p50~51
ASCII

p51
AAA명령어 - ??...
add

p55
AAS명령어 - ??? 
sub 
popf - ???

p56
AAM명령어 - ???


p57
AAD명령어 - ????

p59
DAA - 16진수이면 그걸 무시하고, h를 뺀 숫자(10진수로 h뺀 숫자)를 더해준다.  

p60
DAS명령어 - ????













