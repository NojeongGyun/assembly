<pre>
- <mark>Shift</mark> -
쉬프트연산은 그 비트들을 왼쪽 또는 오른쪽으로 한 칸씩 이동시키는 연산입니다.

<b>SHL(shift left)</b> -
목적 피연산자에 대해 논리적 왼쪽 시프트를 수행하며, 가장 낮은 비트는 0으로 채웁니다.
이떄 가장 높은 비트는 계속해서 밀리게 되고, 마지막 논리적 왼쪽 쉬프트를 하면 밀린 비트가 CF값이 됩니다.
ex) 10001 SHL(1번) -> 00010 (CF = 1) SHL(1번) -> 00100 (CF = 0)
  
<b>SHR(shift right)</b> -
목적 피연산자에 대해 논리적 오른쪽 시프트를 수행하며, 가장 높은 비트는 0으로 대체 됩니다.
이때 가장 낮은 비트는 계속해서 밀리게 되고, 마지막 논리적 오른쪽 쉬프트를 하면 밀린 비트가 CF값이 됩니다.
ex)  10001 SHL(1번) -> 01000 (CF = 1) SHL(1번) -> 00100 (CF = 0)

<b>SAL (shift arithmetic left)</b> -
산술 왼쪽 시프트는 SHL과 똑같은 기능을 수행합니다.
  
<b>SAR (shift arithmetic right)</b> -
목적 피연산자에 대해 산술적 오른쪽 시프트를 수행하며, 가장 높은 비트의 값으로 밀리게 되며, 가장 높은 비트는 변하지 않습니다.
마찬가지로 마지막 산술적 오른쪽 시프트로 밀린 비트가 CF값이 됩니다.
ex) 10001 SAR(1번) -> 11000 (CF = 1) SAR(1번) -> 11100 (CF = 0)

<b>ROL(rotate left)</b> -
모든 비트를 왼쪽으로 이동시키며, 최상위 비트는 Carry 플래그와 최하위 비트 자리(LSB 자리)에 복사됩니다.
ex) 10001 ROL(1번) -> 00011 (CF = 1) ROL(1번) -> 00110 (CF = 0)

<b>ROR(rotate right)</b> -
모든 비트를 오른쪽으로 이동시키며, 최하위 비트(LSB)를 Carry 플래그와 최상위 비트 자리(MSB 자리)에 합니다.
ex) 10001 ROR(1번) -> 11000 (CF = 1) ROR(1번) -> 01100 (CF = 0)

<b>RCL(rotate carry left)</b> -
모든 비트를 왼쪽으로 이동시키고, Carry 플래그 값을 최하위 비트(LSB)에 복사하며, 최상위 비트(MSB)를 Carry 플래그로 복사합니다.
ex) 10001 (CF = 0) RCL(1번) -> 00010 (CF = 1) RCL(1번) -> 00101 (CF = 0)

<b>RCR(rotate carry right)</b> -
모든 비트를 오른쪽으로 이동시키고, Carry 플래그 값을 최상위 비트(MSB)에 복사하며, 최하위 비트(LSB)를 Carry 플래그로 복사합니다.
ex) 10001 (CF = 0) RCR(1번) -> 01000 (CF = 1) RCR(1번) -> 10100 (CF = 0)

<b>SHLD(Shift Left Double)</b>
목적지 오퍼랜드를 지정한 비트 수만큼 왼쪽으로 이동시키는 명령어입니다. 
이때 지정할 비트를 소스 오퍼랜드를 쓰는데, 소스 오퍼랜드의 MSB가 오른쪽에서 계속 채워집니다.
ex) * source : 01110    10001 SHLD(1번) -> 00010 (CF = 1) SHLD(1번) -> 00100 (CF = 0)   
    * source : 11110    10001 SHLD(1번) -> 00011 (CF = 1) SHLD(1번) -> 00111 (CF = 0)

<b>SHRD(shift right double)</b>
목적지 오퍼랜드를 지정한 비트 수만큼 오른쪽으로 이동시키는 명령어입니다. 
이때 지정할 비트를 소스 오퍼랜드를 쓰는데, 소스 오퍼랜드의 LSB가 왼쪽에서 계속 채워집니다.
ex) * source : 01110    10001 SHRD(1번) -> 01000 (CF = 1) SHLD(1번) -> 00100 (CF = 0)
    * source : 01111    10001 SHRD(1번) -> 11000 (CF = 1) SHLD(1번) -> 11100 (CF = 0)

- <mark>mul, imul</mark> -
mul과 imul은 곱셈 명령어입니다. 다만 다른점은 signed 연산을 하냐 하지 않냐의 차이입니다.

<b>mul</b> -
mul명령어는 signed연산을 하지 않고, 곱 연산을 진행합니다.
2-operand 연산일 떄는 목적지 오퍼랜드와 소스 오퍼랜드를 곱하고, 목적지 오퍼랜드에 저장하는식이고,
3-operand 연산일 때는 소스 오퍼랜드 2개끼리 곱한 후 목적지 오퍼랜드에 저장이 됩니다.
하지만 1-operand 연산일떄는 오퍼랜드가 8/16/32 비트인경우 al/ax/eax 값과 곱한 후 ax/dx:ax/edx:eax 에 저장이 됩니다.
ex) mov al, 3   // mul연산일 떄 만약 -3을 넣으면 -3값이 아닌, 256 - 3 = 253 즉 253값으로 인식이 됩니다.
    mov bx, 10
    mul bx    // bx는 10이고 al은 3이므로 10 * 3 = 30 즉 ax에 30값이 저장이 됩니다.  
  
<b>imul</b>
imul명령어는 signed연산을 포함하여 곱 연산을 진행합니다.
1,2,3 - operand는 위에 설명한 것과 같습니다.
ex) mov al, -3   
    mov bx, 10
    imul bx    // imul은 signed연산을 하는 명령어이기에 al은 -3 그대로 들어오고, bx는 10이므로 10 * -3 = -30 즉 ax에 -30값이 저장이 됩니다.

-<mark>div, idiv</mark>
div와 idiv는 나누기 명령어 입니다.  다른점은 signed 연산을 하냐 하지 않냐의 차이입니다.

<b>div</b> -
div명령어는 signed연산을 하지 않고, 나누기 연산을 진행합니다.
mul과 2-operand, 3-operand연산은 비슷합니다. 
하지만 1-operand에서 오퍼랜드가 8/16/32 비트인경우 ax/dx:ax/edx:eax 값과 나눈 후 값은 al/ax/eax에 저장되고, 나머지는 ah/dx/edx에 저장됩니다.

<b>idiv</b> -
idiv명령어는 signed연산을 포함하여, 나누기 연산을 진행합니다.
위에서 설명한 imul원리에 곱 대신 나누기를 넣으면 되고, 
1-operand에서는 div에 설명한 원리를 적용시키면 됩니다.
주의 사항으로 idiv를 할 떄 제시된 비트가 맞지 않으면 부호 확장을 시키고 계산을 하여야합니다.
ex) mov AL, -5 
    cbw  // 부호 확장(al -> ax) 
    idiv bl // bl이 8비트이므로 ax레지스터가 필요하기에 cbw를 써서 부호 확장을 시키고 bl과 나눕니다.

그리고 나눈 몫이 담을 레지스터보다 크면 오버플로우가 발생하기에 사용하는 비트(피연산자)가 크면 클수록 오버플로우가 날 가능성이 적어집니다.

- <mark>ADC(add with carry)</mark> -
ADC명령어는 목적지 오퍼랜드 + 소스 오퍼랜드를 계산 후 CF의 값을 더해주면 됩니다.
계산 해 주면 CF = 0이 되는데, 이때 목적지 오퍼랜드의 비트 범위를 초과하면 목적지 오퍼랜드 + 소스 오퍼랜드 + CF값의 
하위 비트만 남기고 저장되고, CF = 1이 됩니다.

- <mark>SBB(subtract with borrow)</mark> -
SBB명령어는 목적지 오퍼랜드 - 소스 오퍼랜드를 계산 후 CF의 값을 뺴주면 됩니다.
계산하면 CF = 0이 되는데, 만약 언더 플로우가 일어나면 목적지 오퍼랜드 - 소스 오퍼랜드 - CF값의 하위 비트만 남기고 저장되고, CF = 1이 됩니다.

-<mark>Unpacked BCD</mark>-
ASCII 코드로 숫자 한 자리를 표현하면, 그 값의 상위 4비트는 항상 0011b이고, 하위 4비트에는 실제 숫자 값(0~9)이 들어갑니다.
실제 숫자로 만들면 상위 4비트는 0000이 되고, 하위 4비트에는 실제 숫자 값(0~9)을 넣으면 됩니다.

<b>AAA(ASCII adjust after addition)</b> -
AAA명령어는 ADD/ADC 후 AL의 10진수 결과를 올바른 unpacked decimal 형태로 조정합니다.

<b>AAS(ASCII adjust after subtraction)</b> -
AAS명령어는 SUB/SBB 후 결과가 BCD 범위를 벗어나면 AL에서 6을 빼고 AH에서 1을 빼서 정상적인 BCD 형태로 고쳐줍니다.

<b>AAM(ASCII adjust after multiplication)</b> -
AAM명령어는 MUL로 나온 이진 곱셈 결과를 unpacked decimal 10진수 형태로 변환합니다.

<b>AAD(ASCII adjust before division)</b> -
AAD명령어는 AX에 있는 unpacked decimal 값을 DIV 실행을 위해 이진(binary) 형태로 변환합니다

<b>DAA(decimal adjust after addition)</b> -
DAA명령어는 ADD/ADC 후 AL의 이진 합을 packed decimal 형태로 조정합니다.
  
<b>DAS(decimal adjust after subtraction)</b> -
DAS명령어는 SUB/SBB 후 AL의 이진 결과를 packed decimal 형태로 조정합니다.


</pre>










6p
쉬프트를 통해서 곱셈을 더 빨리 할 수 있음
00000101(2진수) = 5   =>(왼쪽 쉬프트 1번) 00001010(2진수) = 5 * 2^1 = 10 
=>(왼쪽 쉬프트 2번) 5 * 2^2 = 20 
반대로 오른쪽 쉬프트를 하면 5 / 2 의 정수?

SHR은 부호를 지키지 않아 음수이면 부호를 바껴 원하는 값을 찾기 힘듬
SAR은 부호를 지키기 위해 MSB의 값을 다시 제값을 찾고, 오른쯕으로 쉬프트 됩니다.

p10
ROl명령어는 왼쪽 쉬프트를 하면 MSB가 CF에 들어가게 되는데, 그 후 MSB는 LSB에 값이 들어갑니다.
밑에 예시에 보면 16진수이면 4개의 2진수 비트가 1개로 묶여있기 때문에 ROL 4번을 하면 16진수 1개의 비트값이 오른쪽에 들어갑니다.




p25
8비트의 mul이 나오면 16비트 레지스터로 저장
mul은 8비트이면 무조권 al의 값을 곱함(묵시적임) -> 이게 명령어가 1개 나온 기준임
결과는 AX에 저장됨
Carry flag에도 연관됨
mul이란 명령은 오퍼랜드 1개만 사용할 때만 쓸수 있음

imul은 오퍼랜드 2개 이상일 때만 사용할 수 있음
목적지오퍼랜드, 소스오퍼랜드, 





p37
cwd - 부호 확장 명령어(SiGN비트가 어떤 숫자에 따라서 부호 확장할때, 1로 채우는지, 0으로 채우는지 결정된다.)

p40
나누기를 하면 플래그 레지스터는 바뀌지 않는다.

p41
div b1을 하면 ax / b1을 하여 ah에 몫, al에 나머지가 저장이 되는데, 나머지에서 al의 비트가 표현할 수 있는 정수의 한도보다 더 채워졌기에 오버플로우가 발생 합니다.

p42
je - 나누기를 할때 0을 나누기 하면 컴퓨터적 오류가 나기에 먼저 je명령어로 0으로 나누는게 아닌지 판단 하고, 여부에 따라 진행 합니다.

p47
ADC명령어 - ??

p48
SBB - 자리 빌림
최상위 비트에서 캐리가 발생하거나, 자리 빌림이 발생하면, 1로 세팅되는게 캐리 플래그입니다. 그럴경우에 carry flag로 같이 연산에 포함하세요 라는게 SBB입니다.













