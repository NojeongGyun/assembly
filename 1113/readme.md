2p 
쉬프트 연산자 종류, 하지만 플래그를 동반하는 쉬프트도 있음

3p
오른쪽 쉬프트를 하면 오른쪽에 캐리된 비트를 CF에 넣고, 왼쪽 쉬프트를 하면 왼쪽에 캐리된 비트를 CF에 넣습니다.

6p
쉬프트 후 CF변화 예시

6p
쉬프트를 통해서 곱셈을 더 빨리 할 수 있음
00000101(2진수) = 5   =>(왼쪽 쉬프트 1번) 00001010(2진수) = 5 * 2^1 = 10 
=>(왼쪽 쉬프트 2번) 5 * 2^2 = 20 
반대로 오른쪽 쉬프트를 하면 5 / 2 의 정수?

SHR은 부호를 지키지 않아 음수이면 부호를 바껴 원하는 값을 찾기 힘듬
SAR은 부호를 지키기 위해 MSB의 값을 다시 제값을 찾고, 오른쯕으로 쉬프트 됩니다.

p10
ROl명령어는 왼쪽 쉬프트를 하면 MSB가 CF에 들어가게 되는데, 그 후 MSB는 LSB에 값이 들어갑니다.
밑에 예시에 보면 16진수이면 4개의 2진수 비트가 1개로 묶여있기 때문에 ROL 4번을 하면 16진수 1개의 비트값이 오른쪽에 들어갑니다.

~
p14
SHLD는 피연산자가 3


p25
8비트의 mul이 나오면 16비트 레지스터로 저장
mul은 8비트이면 무조권 al의 값을 곱함(묵시적임) -> 이게 명령어가 1개 나온 기준임
결과는 AX에 저장됨
Carry flag에도 연관됨
mul이란 명령은 오퍼랜드 1개만 사용할 때만 쓸수 있음

imul은 오퍼랜드 2개 이상일 때만 사용할 수 있음
목적지오퍼랜드, 소스오퍼랜드, 



p34
div는 반대로 al로 나누고, ah에 저장합니다.

p35
몫은 AX, 나머지는 DX에 들어간다.

p37
cwd - 부호 확장 명령어(SiGN비트가 어떤 숫자에 따라서 부호 확장할때, 1로 채우는지, 0으로 채우는지 결정된다.)

p40
나누기를 하면 플래그 레지스터는 바뀌지 않는다.

p41
div b1을 하면 ax / b1을 하여 ah에 몫, al에 나머지가 저장이 되는데, 나머지에서 al의 비트가 표현할 수 있는 정수의 한도보다 더 채워졌기에 오버플로우가 발생 합니다.
















