Q1. [Improved Str_copy Procedure]
The Str_copy procedure shown in this chapter does not limit the number of characters to be copied. 
Create a new version (named Str_copyN) that receives an additional input parameter indicating the maximum number of characters to be copied.
FindLargest.

[해석]
이 장에서 보여준 Str_copy 프로시저는 문자열을 복사할 때 길이를 제한하지 않으므로 최대 복사 길이를 입력받아 
그 수만큼만 문자열을 복사하는 새로운 버전 Str_copyN을 작성하고 배열에서 가장 큰 값을 찾는 FindLargest 프로시저도 만들어 각 프로시저를 테스트하는 짧은 드라이버 프로그램을 작성하라.

------------------------------------------------------[Q1.code]-------------------------------------------------------------------------------------------------------

include Irvine32.inc

.data
srcStr byte "Hello, Assembly!",0
destStr byte 50 dup(?)
arr dword 5, 12, 7, 23, 9
maxChars dword 5

.code

;-----------------------------
; Str_copyN: 최대 maxChars만 복사
; 입력: ESI=source, EDI=dest, ECX=maxChars
;-----------------------------
Str_copyN PROC
    cld
nextChar:
    cmp ecx, 0
    je done
    lodsb
    stosb
    dec ecx
    cmp al, 0
    jne nextChar
done:
    mov al, 0
    stosb
    ret
Str_copyN ENDP

;-----------------------------
; FindLargest: DWORD 배열 최대값
; 입력: ESI=array pointer, ECX=element count
; 출력: EAX=최대값
;-----------------------------
FindLargest PROC
    mov eax, [esi]
    dec ecx
    add esi, 4
nextElement:
    cmp ecx, 0
    je done
    mov edx, [esi]
    cmp edx, eax
    jle skip
    mov eax, edx
skip:
    add esi, 4
    dec ecx
    jmp nextElement
done:
    ret
FindLargest ENDP

;-----------------------------
; main: 드라이버 테스트
;-----------------------------
main PROC
    ; Str_copyN 테스트
    mov esi, offset srcStr
    mov edi, offset destStr
    mov ecx, maxChars
    call Str_copyN

    ; 문자열 출력 확인
    mov edx, offset destStr
    call WriteString
    call Crlf

    ; FindLargest 테스트
    mov esi, offset arr
    mov ecx, 5
    call FindLargest      ; EAX = 23

    ; 최대값 출력
    call WriteDec
    call Crlf

    exit
main ENDP

END main

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q2. [Str_concat Procedure]
Write a procedure named Str_concat that concatenates a source string to the end of a target
string. Sufficient space must exist in the target string to accommodate the new characters. Pass
pointers to the source and target strings. Here is a sample call:
                                                                 (코드1)
                                                                 .data
                                                                 targetStr BYTE "ABCDE",10 DUP(0)
                                                                 sourceStr BYTE "FGH",0
                                                                 .code
                                                                 INVOKE Str_concat, ADDR targetStr, ADDR sourceStr


[해석]
Str_concat이라는 프로시저를 작성하라. 이 프로시저는 source 문자열을 target 문자열 끝에 이어 붙인다.
단, target 문자열에는 새 문자열을 담을 충분한 공간이 있어야 한다. source와 target 문자열의 포인터를 전달한다. 예제 호출 형태가 제공된다. (코드1)

------------------------------------------------------[Q2.code]-------------------------------------------------------------------------------------------------------

include Irvine32.inc

.data
targetStr byte "Hello, ", 50 dup(?)
sourceStr byte "World!", 0

.code

;-----------------------------
; Str_concat: source 문자열을 target 끝에 이어 붙임
; 입력: ESI = source, EDI = target
;-----------------------------
Str_concat PROC
    cld

    ; target 끝으로 이동
findEnd:
    mov al, [edi]
    cmp al, 0
    je copySource
    inc edi
    jmp findEnd

copySource:
    lodsb           ; AL = [ESI], ESI++
    cmp al, 0
    je done
    stosb           ; [EDI] = AL, EDI++
    jmp copySource

done:
    mov al, 0
    stosb           ; null 종료
    ret
Str_concat ENDP

;-----------------------------
; main: 테스트용 드라이버
;-----------------------------
main PROC
    mov esi, offset sourceStr
    mov edi, offset targetStr
    call Str_concat

    ; 결과 출력
    mov edx, offset targetStr
    call WriteString
    call Crlf

    exit
main ENDP

END main

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q3. [Str_remove Procedure]
Write a procedure named Str_remove that removes n characters from a string. Pass a pointer to
the position in the string where the characters are to be removed. Pass an integer specifying the
number of characters to remove. The following code, for example, shows how to remove “xxxx”
from target:
           (코드1)
            .data
            target BYTE "abcxxxxdefghijklmop",0
            .code
            INVOKE Str_remove, ADDR [target+3], 4

[해석]
Str_remove라는 프로시저를 작성하라. 이 프로시저는 문자열에서 n개의 문자를 제거한다.
제거를 시작할 위치를 가리키는 포인터와, 제거할 문자 수를 지정하는 정수를 전달한다.
예를 들어, target 문자열에서 "xxxx"를 제거할 수 있는 코드가 제공된다. (코드1)

------------------------------------------------------[Q3.code]-------------------------------------------------------------------------------------------------------

include Irvine32.inc

.data
targetStr byte "Hello xxxx World!",0
removePos byte 6         ; 제거 시작 위치: 6번째 문자부터
removeCount dword 4      ; 제거할 문자 수: 4

.code

;-----------------------------
; Str_remove: 문자열에서 n문자 제거
; 입력: ESI = 제거 시작 위치 포인터, ECX = 제거할 문자 수
;-----------------------------
Str_remove PROC
    cld
    mov edi, esi          ; EDI = 제거 시작 위치

    ; 제거할 위치 이후 문자 시작으로 이동
    lea esi, [edi + ecx]  ; ESI = 제거할 n문자 뒤 위치

shiftLoop:
    mov al, [esi]         ; AL = [ESI]
    stosb                  ; [EDI] = AL, EDI++
    inc esi
    cmp al, 0
    jne shiftLoop          ; null 만날 때까지 반복

    ret
Str_remove ENDP

;-----------------------------
; main: 테스트용 드라이버
;-----------------------------
main PROC
    ; 제거 시작 위치 계산
    mov esi, offset targetStr
    add esi, removePos    ; 제거 시작 위치 포인터
    mov ecx, removeCount  ; 제거할 문자 수
    call Str_remove

    ; 결과 출력
    mov edx, offset targetStr
    call WriteString
    call Crlf

    exit
main ENDP

END main

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q4. [Str_find Procedure]
Write a procedure named Str_find that searches for the first matching occurrence of a source string
inside a target string and returns the matching position. The input parameters should be a pointer to
the source string and a pointer to the target string. If a match is found, the procedure sets the Zero
flag and EAX points to the matching position in the target string. Otherwise, the Zero flag is clear
and EAX is undefined. The following code, for example, searches for “ABC” and returns with EAX
pointing to the “A” in the target string:
                                         (코드1)
                                         .data
                                         target BYTE "123ABC342432",0
                                         source BYTE "ABC",0
                                         pos DWORD ?
                                        .code
                                         INVOKE Str_find, ADDR source, ADDR target
                                         jnz notFound
                                         mov pos,eax ; store the position value
[해석]
Str_find라는 프로시저를 작성하라. 이 프로시저는 target 문자열 안에서 source 문자열의 첫 번째 일치 항목을 검색하고, 일치하는 위치를 반환한다.
입력 파라미터는 source 문자열 포인터와 target 문자열 포인터이다. 
일치 항목이 발견되면 → Zero 플래그가 설정되고(EAX = 일치 위치 포인터)
발견되지 않으면 → Zero 플래그가 클리어되고(EAX는 정의되지 않음)
예를 들어, "ABC"를 검색하면 EAX가 target 문자열 안의 "A"를 가리키도록 반환한다. (코드1)

------------------------------------------------------[Q4.code]-------------------------------------------------------------------------------------------------------

include Irvine32.inc

.data
targetStr byte "XYZABC123",0
sourceStr byte "ABC",0

.code

;-----------------------------
; Str_find: source 문자열을 target에서 검색
; 입력: ESI=source pointer, EDI=target pointer
; 출력: EAX = target에서 일치 위치 포인터 (ZF=1)
;        없으면 ZF=0, EAX undefined
;-----------------------------
Str_find PROC
    cld
    mov eax, edi          ; EAX = 현재 target 위치

nextChar:
    mov esi, offset sourceStr  ; source 시작 위치
    mov edx, eax               ; target 비교 시작 위치

compareLoop:
    mov bl, [esi]              ; source 문자
    cmp bl, 0
    je found                   ; source 끝 → 일치 발견
    mov bh, [edx]              ; target 문자
    cmp bh, 0
    je notFound                ; target 끝 → 검색 실패
    cmp bl, bh
    jne noMatch
    inc esi
    inc edx
    jmp compareLoop

noMatch:
    inc eax                     ; target 다음 위치로 이동
    cmp byte ptr [eax], 0
    je notFound
    jmp nextChar

found:
    mov eax, edx
    dec eax                     ; eax는 비교 후 edx 증가 → 원래 시작 위치 보정
    stc                         ; ZF = 1 대신 C로 표시 가능, Irvine32에서 WriteString 확인용
    ret

notFound:
    clc                         ; ZF = 0
    ret
Str_find ENDP

;-----------------------------
; main: 테스트용 드라이버
;-----------------------------
main PROC
    mov edi, offset targetStr
    call Str_find

    ; 일치 여부 출력
    cmp eax, 0
    je NotFound
    ; 일치 위치 출력 (targetStr의 일부만 출력)
    mov edx, eax
    call WriteString
    call Crlf
    jmp Done

NotFound:
    mov edx, offset targetStr
    call WriteString
    call Crlf

Done:
    exit
main ENDP

END main

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q5. [Str_nextWord Procedure]
Write a procedure called Str_nextWord that scans a string for the first occurrence of a certain
delimiter character and replaces the delimiter with a null byte. There are two input parameters: a
pointer to the string and the delimiter character. After the call, if the delimiter was found, the Zero
flag is set and EAX contains the offset of the next character beyond the delimiter. Otherwise, the
Zero flag is clear and EAX is undefined. The following example code passes the address of target
and a comma as the delimiter:
                             (코드1)
                             .data
                             target BYTE "Johnson,Calvin",0
                             .code
                             INVOKE Str_nextWord, ADDR target, ','
                             jnz notFound
                             In Figure 9-5, after calling Str_nextWord, EAX points to the character following the position
                             where the comma was found (and replaced). 

[해석]
Str_nextWord라는 프로시저를 작성하라. 이 프로시저는 문자열 안에서 특정 구분자(delimiter) 문자의 첫 번째 등장 위치를 찾아 그 문자를 널 바이트(0)로 교체한다.
입력 파라미터: 문자열 포인터와 구분자 문자
호출 후:
  구분자가 발견되면 → Zero 플래그가 설정되고(EAX = 구분자 바로 다음 문자 주소)
  구분자가 없으면 → Zero 플래그가 클리어되고(EAX는 정의되지 않음)
예시: target 문자열 주소와 구분자 ','를 전달한다. (코드1)

------------------------------------------------------[Q5.code]-------------------------------------------------------------------------------------------------------

include Irvine32.inc

.data
targetStr byte "Hello,World,Assembly",0
delimiter byte ','

.code

;-----------------------------
; Str_nextWord: 문자열에서 delimiter 찾아 null로 바꿈
; 입력: EDI=문자열 포인터, AL=delimiter 문자
; 출력: EAX = delimiter 다음 문자 주소 (ZF=1), 없으면 ZF=0
;-----------------------------
Str_nextWord PROC
    cld
    mov eax, edi       ; 현재 위치 저장

scanLoop:
    mov bl, [eax]      ; 현재 문자
    cmp bl, 0
    je notFound        ; 문자열 끝 → delimiter 없음
    cmp bl, al         ; delimiter 비교
    jne nextChar
    mov byte ptr [eax], 0   ; delimiter를 null로 교체
    inc eax                  ; 다음 문자 주소
    stc                      ; ZF=1 대신 carry set (Irvine32 간단 표시)
    ret

nextChar:
    inc eax
    jmp scanLoop

notFound:
    clc                      ; ZF=0 대신 carry clear
    ret
Str_nextWord ENDP

;-----------------------------
; main: 테스트용 드라이버
;-----------------------------
main PROC
    mov edi, offset targetStr
    mov al, delimiter
    call Str_nextWord

    ; 결과 출력
    mov edx, offset targetStr
    call WriteString
    call Crlf

    ; 다음 단어 출력 (EAX 포인터)
    call WriteString        ; Irvine32에서 EAX는 offset 필요, 실제 실행시 mov edx, eax 필요
    call Crlf

    exit
main ENDP

END main

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q6. [Constructing a Frequency Table]
Write a procedure named Get_frequencies that constructs a character frequency table. Input to
the procedure should be a pointer to a string and a pointer to an array of 256 doublewords initialized to all zeros. Each array position is indexed by its corresponding ASCII code. 
When the procedure returns, each entry in the array contains a count of how many times the corresponding
character occurred in the string. For example,
                                              (코드1)
                                              .data
                                              target BYTE "AAEBDCFBBC",0
                                              freqTable DWORD 256 DUP(0)
                                              .code
                                              INVOKE Get_frequencies, ADDR target, ADDR freqTable
Figure 9-6 shows a picture of the string and entries 41 (hexadecimal) through 4B in the frequency table. Position 41 contains the value 2 because the letter A (ASCII code 41h) occurred
twice in the string. Similar counts are shown for other characters. Frequency tables are useful in
data compression and other applications involving character processing. The Huffman encoding
algorithm, for example, stores the most frequently occurring characters in fewer bits than other
characters that occur less often.

[해석]
Get_frequencies라는 프로시저를 작성하라. 이 프로시저는 문자열 안에서 각 문자의 등장 횟수(frequency)를 계산하여 256 요소 배열에 저장하라. 예시는 (코드1)
그림 9-6은 문자열과 빈도 테이블에서 41h(16진수)부터 4Bh까지의 항목을 보여준다.
배열 위치 41h에는 값 2가 들어 있는데, 이는 문자 'A'(ASCII 코드 41h)가 문자열에 두 번 등장했기 때문이다.
다른 문자들도 비슷하게 등장 횟수가 기록되어 있다.
빈도 테이블은 데이터 압축이나 문자를 다루는 다양한 응용 프로그램에서 유용하다.
예를 들어, Huffman 인코딩 알고리즘은 문자열에서 가장 자주 등장하는 문자를 더 적은 비트로 저장하고, 덜 자주 등장하는 문자는 더 많은 비트로 저장한다.

------------------------------------------------------[Q6.code]-------------------------------------------------------------------------------------------------------

include Irvine32.inc

.data
target BYTE "AAEBDCFBBC",0
freqTable DWORD 256 DUP(0)

.code

;-----------------------------
; Get_frequencies: 문자열에서 문자 빈도 계산
; 입력: ESI = 문자열 포인터, EDI = freqTable 포인터
;-----------------------------
Get_frequencies PROC
    cld
freqLoop:
    mov al, [esi]        ; 현재 문자
    cmp al, 0
    je done              ; 문자열 끝
    mov ebx, eax         ; EBX = ASCII 코드 (0~255)
    mov eax, [edi + ebx*4] ; 현재 count
    inc eax
    mov [edi + ebx*4], eax ; 증가된 count 저장
    mov eax, ebx         ; EBX -> EAX 복원
    inc esi
    jmp freqLoop

done:
    ret
Get_frequencies ENDP

;-----------------------------
; main: 테스트용 드라이버
;-----------------------------
main PROC
    INVOKE Get_frequencies, ADDR target, ADDR freqTable

    ; 예시: 문자 'A'와 'B' 빈도 출력
    mov eax, freqTable[41h*4]   ; 'A' ASCII 41h
    call WriteDec
    call Crlf

    mov eax, freqTable[42h*4]   ; 'B' ASCII 42h
    call WriteDec
    call Crlf

    mov eax, freqTable[43h*4]   ; 'C' ASCII 43h
    call WriteDec
    call Crlf

    exit
main ENDP

END main

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q7. [Sieve of Eratosthenes]
The Sieve of Eratosthenes, invented by the Greek mathematician of the same name, provides a
quick way to find all prime numbers within a given range. The algorithm involves creating an array
of bytes in which positions are “marked” by inserting 1s in the following manner: Beginning with
position 2 (which is a prime number), insert a 1 in each array position that is a multiple of 2. Then
do the same thing for multiples of 3, the next prime number. Find the next prime number after 3,
which is 5, and mark all positions that are multiples of 5. Proceed in this manner until all multiples
of primes have been found. The remaining positions of the array that are unmarked indicate which
numbers are prime. For this program, create a 65,000-element array and display all primes
between 2 and 65,000. Declare the array in an uninitialized data segment (see Section 3.4.11) and
use STOSB to fill it with zeros.

[해석]
그리스 수학자 에라토스테네스가 고안한 Sieve of Eratosthenes는 주어진 범위 안에서 모든 소수를 빠르게 찾는 방법이다.
1. 바이트 배열 생성: 각 위치는 숫자를 나타내고, 1을 넣으면 “소수가 아님”을 표시한다.
2. 처음 위치 2부터 시작: 2의 배수마다 1을 넣는다.
3. 다음 소수 3: 3의 배수마다 1을 넣는다.
4. 다음 소수 5 → 마찬가지로 배수를 1로 표시.
  이 과정을 반복 → 배수가 아닌 위치가 남으면 소수임.
이 프로그램에서는 65,000개 요소 배열을 만들고 2~65,000 사이의 모든 소수를 표시한다.
배열은 uninitialized data segment에 선언하고, STOSB를 사용해 0으로 초기화한다.

------------------------------------------------------[Q7.code]-------------------------------------------------------------------------------------------------------

include Irvine32.inc

.data?
sieveArray byte 65000 dup(?)   ; uninitialized array

.code
main PROC
    cld
    mov edi, offset sieveArray
    mov ecx, 65000
    xor al, al
    rep stosb                   ; 배열 0으로 초기화

    ; 소수 찾기: 에라토스테네스 체
    mov ecx, 65000
    mov ebx, 2                  ; 시작 소수 2

nextPrime:
    cmp ebx, 65000
    ja doneSieve

    ; ebx의 배수를 1로 표시
    mov eax, ebx
    mov edi, offset sieveArray
    add edi, eax                ; 첫 배수 위치
markMultiples:
    cmp eax, 65000
    ja nextPrimeCalc
    mov byte ptr [edi], 1
    add eax, ebx
    add edi, ebx
    jmp markMultiples

nextPrimeCalc:
    ; 다음 소수 찾기
    inc ebx
    ; ebx가 이미 표시되었으면 건너뜀
    mov al, [sieveArray + ebx]
    cmp al, 0
    jne nextPrimeCalc
    jmp nextPrime

doneSieve:
    ; 소수 출력
    mov eax, 2
printLoop:
    cmp eax, 65001
    ja exitProgram
    mov bl, [sieveArray + eax]
    cmp bl, 0
    jne skipPrint
    mov edx, eax
    call WriteDec
    call Crlf
skipPrint:
    inc eax
    jmp printLoop

exitProgram:
    exit
main ENDP

END main

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q8. [Bubble Sort]
Add a variable to the BubbleSort procedure in Section 9.5.1 that is set to 1 whenever a pair of
values is exchanged within the inner loop. Use this variable to exit the sort before its normal
completion if you discover that no exchanges took place during a complete pass through the
array. (This variable is commonly known as an exchange flag.)

[해석]
“BubbleSort 프로시저에 변수를 추가하라.
조건 :
  inner loop에서 값이 교환될 때마다 이 변수를 1로 설정
  inner loop가 끝난 후: 변수가 0이면, 즉 교환이 한 번도 발생하지 않았으면, 정렬을 조기 종료
이렇게 하면 이미 정렬된 배열에서는 불필요한 패스가 생략된다.

------------------------------------------------------[Q8.code]-------------------------------------------------------------------------------------------------------

include Irvine32.inc

.data
arr DWORD 10, 3, 5, 2, 8, 7, 6, 1, 4, 9
n DWORD 10
temp DWORD ?
exchanged DWORD ?        ; exchange flag

.code

;-----------------------------
; BubbleSort with exchange flag
; 입력: arr 배열, n = 요소 수
;-----------------------------
BubbleSort PROC
    mov ecx, n             ; 외부 루프 카운터 i = n
outerLoop:
    dec ecx
    cmp ecx, 0
    jle doneSort

    xor eax, eax           ; exchanged = 0
    mov exchanged, eax

    mov edi, offset arr    ; 배열 시작 위치
    mov ebx, ecx           ; inner loop count
innerLoop:
    mov eax, [edi]         ; 현재 값
    mov edx, [edi+4]       ; 다음 값
    cmp eax, edx
    jle noSwap
    ; swap
    mov [edi], edx
    mov [edi+4], eax
    mov exchanged, 1       ; 교환 발생
noSwap:
    add edi, 4
    dec ebx
    jnz innerLoop

    cmp exchanged, 0
    je doneSort            ; 교환 없으면 조기 종료
    jmp outerLoop

doneSort:
    ret
BubbleSort ENDP

;-----------------------------
; main: 테스트용 드라이버
;-----------------------------
main PROC
    call BubbleSort

    ; 정렬 결과 출력
    mov ecx, n
    mov edi, offset arr
printLoop:
    mov eax, [edi]
    call WriteDec
    call Crlf
    add edi, 4
    loop printLoop

    exit
main ENDP

END main

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q9. [Binary Search]
Rewrite the binary search procedure shown in this chapter by using registers for mid, first, and
last. Add comments to clarify the registers’ usage.

[해석]
이 장에서 보여준 Binary Search 프로시저를 레지스터만 사용하도록 재작성하라.
조건: 
  mid, first, last 값을 모두 레지스터로 관리
  레지스터 사용 용도를 주석으로 명확히 표시

------------------------------------------------------[Q9.code]-------------------------------------------------------------------------------------------------------

include Irvine32.inc

.data
arr DWORD 1,3,5,7,9,11,13,15,17,19
n DWORD 10
searchVal DWORD 7

.code

;-----------------------------
; BinarySearch using registers only
; 입력: EAX = 찾을 값
; 출력: EAX = 배열에서 찾은 값의 주소, ZF=1이면 발견, ZF=0이면 미발견
; 레지스터 사용:
;   ESI = 배열 시작 주소
;   EDI = first index
;   EBX = last index
;   ECX = mid index
;-----------------------------
BinarySearch PROC
    mov esi, offset arr      ; ESI = 배열 시작 주소
    xor edi, edi             ; EDI = first index = 0
    mov ebx, n
    dec ebx                  ; EBX = last index = n-1

searchLoop:
    cmp edi, ebx
    ja notFound              ; first > last → 검색 실패

    mov ecx, edi
    add ecx, ebx
    shr ecx, 1               ; mid = (first + last)/2

    mov edx, [esi + ecx*4]  ; 현재 mid 값
    cmp eax, edx
    je found

    jl lessThanMid
    ; searchVal > mid → first = mid +1
    mov edi, ecx
    inc edi
    jmp searchLoop

lessThanMid:
    ; searchVal < mid → last = mid -1
    mov ebx, ecx
    dec ebx
    jmp searchLoop

found:
    ; 찾은 위치 EAX 반환
    lea eax, [esi + ecx*4]
    stc                     ; ZF=1 대신 carry set (Irvine32에서 간단 표시)
    ret

notFound:
    clc                     ; ZF=0 대신 carry clear
    ret
BinarySearch ENDP

;-----------------------------
; main: 테스트용 드라이버
;-----------------------------
main PROC
    mov eax, searchVal
    call BinarySearch

    ; 결과 출력
    ; ZF 확인 후 주소 출력
    jc foundLabel
    mov edx, offset arr
    call WriteString
    call Crlf
    jmp done

foundLabel:
    ; EAX = 찾은 값 주소
    mov edx, eax
    call WriteDec
    call Crlf

done:
    exit
main ENDP

END main


----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q10.[Letter Matrix]
Create a procedure that generates a four-by-four matrix of randomly chosen capital letters.
When choosing the letters, there must be a 50% probability that the chosen letter is a vowel.
Write a test program with a loop that calls your procedure five times and displays each matrix in
the console window. Following is sample output for the first three matrices:
                                                                             (행렬1)
                                                                             D W A L
                                                                             S I V W
                                                                             U I O L
                                                                             L A I I
                                                                             K X S V
                                                                             N U U O
                                                                             O R Q O
                                                                             A U U T
                                                                             P O A Z
                                                                             A E A U
                                                                             G K A E
                                                                             I A G D
[해석]
4x4 행렬을 생성하는 프로시저를 작성하라.
조건 :
  랜덤 대문자(A~Z) 선택
  50% 확률로 모음(A, E, I, O, U) 선택
테스트 프로그램: 루프 5회 반복 → 각 행렬을 콘솔에 출력

------------------------------------------------------[Q10.code]-------------------------------------------------------------------------------------------------------

include Irvine32.inc

.data
vowels BYTE 'A','E','I','O','U'
matrix BYTE 16 DUP(?)      ; 4x4 행렬 저장

.code

;-----------------------------
; Generate4x4Matrix: 4x4 랜덤 대문자 생성
; 입력: 없음
; 출력: matrix 배열에 랜덤 대문자 채움
;-----------------------------
Generate4x4Matrix PROC
    mov ecx, 16              ; 16 문자 생성
    lea edi, matrix

genLoop:
    call RandomRange10        ; 0~9 랜덤 생성
    cmp eax, 4                ; 0~4 = 모음 선택 (약 50% 확률)
    jle pickVowel
    ; 자음 선택
    call RandomRange20        ; 0~20
    add al, 'A'
    ; 모음(A,E,I,O,U) 걸러내기
    cmp al, 'A'
    je skipA
    cmp al, 'E'
    je skipA
    cmp al, 'I'
    je skipA
    cmp al, 'O'
    je skipA
    cmp al, 'U'
    je skipA
    jmp storeChar
skipA:
    inc al
storeChar:
    mov [edi], al
    inc edi
    loop genLoop
    ret

pickVowel:
    call RandomRange4         ; 0~4
    mov bl, al
    mov al, vowels[ebx]
    mov [edi], al
    inc edi
    loop genLoop
    ret
Generate4x4Matrix ENDP

;-----------------------------
; main: 테스트용 드라이버
;-----------------------------
main PROC
    mov ecx, 5                ; 5번 반복

matrixLoop:
    call Generate4x4Matrix

    ; 행렬 출력 (4x4)
    lea esi, matrix
    mov ebx, 4               ; 행 4
rowLoop:
    push ebx
    mov ecx, 4               ; 열 4
colLoop:
    lodsb
    call WriteChar
    mov al,' '
    call WriteChar           ; 공백 출력
    loop colLoop
    call Crlf                ; 행 끝
    pop ebx
    dec ebx
    jnz rowLoop

    call Crlf                ; 행렬 끝 후 한 줄 띄움
    loop matrixLoop

    exit
main ENDP

END main

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q11.[Letter Matrix/Sets with Vowels]
Use the letter matrix generated in the previous programming exercise as a starting point for this
program. Generate a single random four-by-four letter matrix in which each letter has a 50% probability of being a vowel. Traverse each matrix row, column, and diagonal, generating sets of letters.
Display only four-letter sets containing exactly two vowels. Suppose, for example, the following
matrix was generated:
                     (행렬1)
                     P O A Z
                     A E A U
                     G K A E
                     I A G D
Then the four-letter sets displayed by the program would be POAZ, GKAE, IAGD, PAGI,
ZUED, PEAD, and ZAKI. The order of letters within each set is unimportant.

[해석]
이전 문제에서 생성한 4x4 랜덤 대문자 행렬을 사용
50% 확률로 모음(A, E, I, O, U) 선택
행, 열, 대각선을 따라 모든 4글자 세트 생성
조건: 
  4글자 세트에서 정확히 2개의 모음 포함 시 출력
예시 : 
  (행렬1)
출력될 수 있는 세트: 
  POAZ, GKAE, IAGD, PAGI, ZUED, PEAD, ZAKI

------------------------------------------------------[Q11.code]-------------------------------------------------------------------------------------------------------

include Irvine32.inc

.data
vowels BYTE 'A','E','I','O','U'
matrix BYTE 16 DUP(?)      ; 4x4 행렬
msg BYTE "4-letter sets with exactly 2 vowels:",0

.code

;-----------------------------
; Generate4x4Matrix: 4x4 랜덤 대문자 생성
; 50% 확률 모음
;-----------------------------
Generate4x4Matrix PROC
    mov ecx,16
    lea edi,matrix
genLoop:
    call RandomRange10
    cmp eax,4
    jle pickVowel
    call RandomRange20
    add al,'A'
    cmp al,'A'
    je skipA
    cmp al,'E'
    je skipA
    cmp al,'I'
    je skipA
    cmp al,'O'
    je skipA
    cmp al,'U'
    je skipA
    jmp storeChar
skipA:
    inc al
storeChar:
    mov [edi],al
    inc edi
    loop genLoop
    ret
pickVowel:
    call RandomRange4
    mov bl,al
    mov al,vowels[ebx]
    mov [edi],al
    inc edi
    loop genLoop
    ret
Generate4x4Matrix ENDP

;-----------------------------
; IsVowel: AL이 모음이면 ZF=1
;-----------------------------
IsVowel PROC
    mov bl,al
    mov al,'A'
    cmp bl,al
    je vowelFound
    mov al,'E'
    cmp bl,al
    je vowelFound
    mov al,'I'
    cmp bl,al
    je vowelFound
    mov al,'O'
    cmp bl,al
    je vowelFound
    mov al,'U'
    cmp bl,al
    je vowelFound
    xor eax,eax
    ret
vowelFound:
    mov eax,1
    ret
IsVowel ENDP

;-----------------------------
; CountVowels: 포인터 + 길이 4
;-----------------------------
CountVowels PROC
    push ecx
    push esi
    xor eax,eax        ; vowel count
    mov ecx,4
countLoop:
    lodsb
    push eax
    call IsVowel
    add eax,[esp]
    pop eax
    loop countLoop
    pop esi
    pop ecx
    ret
CountVowels ENDP

;-----------------------------
; Print4LetterSet: 포인터로 4글자 출력
;-----------------------------
Print4LetterSet PROC
    mov ecx,4
printLoop:
    lodsb
    call WriteChar
    loop printLoop
    call Crlf
    ret
Print4LetterSet ENDP

;-----------------------------
; main: 테스트 드라이버
;-----------------------------
main PROC
    call Generate4x4Matrix

    ; 메시지 출력
    mov edx,offset msg
    call WriteString
    call Crlf

    ; 행렬 주소
    lea esi,matrix

    ; --- 행 검사 ---
    mov ecx,4
    xor edi,edi
rowLoop:
    push edi
    lea ebx,matrix
    add ebx, edi*4
    mov esi,ebx
    call CountVowels
    cmp eax,2
    jne skipRow
    lea esi,ebx
    call Print4LetterSet
skipRow:
    pop edi
    inc edi
    loop rowLoop

    ; --- 열 검사 ---
    mov ecx,4
    xor edi,edi
colLoop:
    xor eax,eax
    mov esi, offset matrix
    mov ebx,0
colGather:
    mov al, matrix[ebx*4+edi]
    mov matrix[ebx],al
    inc ebx
    cmp ebx,4
    jl colGather
    lea esi,matrix
    call CountVowels
    cmp eax,2
    jne skipCol
    lea esi,matrix
    call Print4LetterSet
skipCol:
    inc edi
    loop colLoop

    ; --- 왼쪽 위 → 오른쪽 아래 대각선 ---
    mov al,matrix[0]
    mov matrix[0],al
    mov al,matrix[5]
    mov matrix[1],al
    mov al,matrix[10]
    mov matrix[2],al
    mov al,matrix[15]
    mov matrix[3],al
    lea esi,matrix
    call CountVowels
    cmp eax,2
    jne skipDiag1
    lea esi,matrix
    call Print4LetterSet
skipDiag1:

    ; --- 오른쪽 위 → 왼쪽 아래 대각선 ---
    mov al,matrix[3]
    mov matrix[0],al
    mov al,matrix[6]
    mov matrix[1],al
    mov al,matrix[9]
    mov matrix[2],al
    mov al,matrix[12]
    mov matrix[3],al
    lea esi,matrix
    call CountVowels
    cmp eax,2
    jne skipDiag2
    lea esi,matrix
    call Print4LetterSet
skipDiag2:

    exit
main ENDP

END main

------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q12.[Calculating the Sum of an Array Row]
Write a procedure named calc_row_sum that calculates the sum of a single row in a two-dimensional
array of bytes, words, or doublewords. The procedure should have the following stack parameters: array offset, row size, array type, row index. It must return the sum in EAX. Use explicit
stack parameters, not INVOKE or extended PROC. Write a program that tests your procedure
with arrays of byte, word, and doubleword. Prompt the user for the row index, and display the
sum of the selected row.

[해석]
스택 매개변수로 배열 시작 주소, 한 행의 크기, 배열 타입(byte/word/dword), 행 인덱스를 받아 2차원 배열의 특정 행 합계를 계산하고 EAX에 반환하는 calc_row_sum 프로시저를 작성하고, 
이를 테스트하는 프로그램을 만들어 사용자가 행 번호를 입력하면 해당 행의 합계를 출력하라.


------------------------------------------------------[Q12.code]-------------------------------------------------------------------------------------------------------

INCLUDE Irvine32.inc

.data
; -------------------------------
; 테스트용 2차원 배열
; -------------------------------
byteArray  BYTE  1,2,3,4,5,
                10,20,30,40,50,
                6,7,8,9,10

wordArray  WORD  1,2,3,4,5,
                10,20,30,40,50,
                6,7,8,9,10

dwordArray DWORD 1,2,3,4,5,
                10,20,30,40,50,
                6,7,8,9,10

promptRow  BYTE "Row index(0~2): ",0
msgByte    BYTE "BYTE row sum = ",0
msgWord    BYTE "WORD row sum = ",0
msgDword   BYTE "DWORD row sum = ",0

.code
main PROC
    ; -----------------------------
    ; 사용자에게 row index 입력받기
    ; -----------------------------
    mov edx, OFFSET promptRow
    call WriteString
    call ReadInt
    mov ebx, eax        ; EBX = row index (0~2)

    ; -----------------------------
    ; BYTE 배열 테스트
    ; -----------------------------
    push ebx                    ; row index
    push 1                      ; arrayType = BYTE = 1
    push 5                      ; row size = 5 elements
    push OFFSET byteArray       ; array offset
    call calc_row_sum
    add esp, 16

    mov edx, OFFSET msgByte
    call WriteString
    call WriteInt
    call Crlf


    ; -----------------------------
    ; WORD 배열 테스트
    ; -----------------------------
    push ebx
    push 2                      ; arrayType = WORD = 2 bytes
    push (5 * 2)                ; row size in bytes
    push OFFSET wordArray
    call calc_row_sum
    add esp, 16

    mov edx, OFFSET msgWord
    call WriteString
    call WriteInt
    call Crlf


    ; -----------------------------
    ; DWORD 배열 테스트
    ; -----------------------------
    push ebx
    push 4                      ; arrayType = DWORD = 4 bytes
    push (5 * 4)                ; row size in bytes
    push OFFSET dwordArray
    call calc_row_sum
    add esp,16

    mov edx, OFFSET msgDword
    call WriteString
    call WriteInt
    call Crlf

    exit
main ENDP


; ============================================================
; calc_row_sum
;   explicit stack parameters 사용
;   [ebp+8]  = array offset (주소)
;   [ebp+12] = row size in bytes
;   [ebp+16] = array type size (1,2,4)
;   [ebp+20] = row index
;   return eax = sum of the row
; ============================================================
calc_row_sum PROC
    push ebp
    mov ebp, esp
    push esi
    push edi
    push ebx

    ; 스택에서 인자 꺼내기
    mov esi, [ebp+8]      ; base address of array
    mov ebx, [ebp+12]     ; row size (bytes)
    mov ecx, [ebp+16]     ; array type size (1,2,4)
    mov edx, [ebp+20]     ; row index

    ; -----------------------------------------
    ; ESI = row start address = base + rowIndex * rowSize
    ; -----------------------------------------
    mov eax, edx
    mul ebx               ; eax = rowIndex * rowSize
    add esi, eax          ; ESI = row start address

    ; 배열의 요소 개수 = rowSizeBytes / typeSize
    mov eax, ebx
    cdq
    idiv ecx              ; eax = number of elements
    mov edi, eax          ; EDI = count

    xor eax, eax          ; sum = 0

sum_loop:
    cmp ecx, 1
    je read_byte
    cmp ecx, 2
    je read_word

    ; ------ DWORD ------
    mov ebx, [esi]
    add eax, ebx
    add esi, 4
    jmp next

read_word:
    movzx ebx, WORD PTR [esi]
    add eax, ebx
    add esi, 2
    jmp next

read_byte:
    movzx ebx, BYTE PTR [esi]
    add eax, ebx
    add esi, 1

next:
    dec edi
    jnz sum_loop

    pop ebx
    pop edi
    pop esi
    pop ebp
    ret
calc_row_sum ENDP

END main

------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q13.[ Trimming Leading Characters]
Create a variant of the Str_trim procedure that lets the caller remove all instances of a leading
character from a string. For example, if you were to call it with a pointer to the string “###ABC”
and pass it the # character, the resulting string would be “ABC".

[해석]
주어진 문자를 전달받아 문자열의 앞부분에서 그 문자와 같은 모든 문자들을 제거한 뒤 남은 부분만 남기는 Str_trim 함수의 변형 버전을 만들어라


------------------------------------------------------[Q13.code]-------------------------------------------------------------------------------------------------------

INCLUDE Irvine32.inc

.data
str1 BYTE "###ABC",0
msg  BYTE "Result: ",0

.code

; ----------------------------------------------------------
; Str_trim_leading_char
; Removes all leading occurrences of a given character.
;
; Stack parameters:
;   [ebp+8]  = pointer to string
;   [ebp+12] = character to remove (BYTE)
;
; Example: "###ABC", '#' → "ABC"
; ----------------------------------------------------------

Str_trim_leading_char PROC
    push ebp
    mov  ebp, esp
    push esi
    push edi

    mov esi, [ebp+8]      ; string pointer
    mov bl,  [ebp+12]     ; character to remove

; --------------------------------------
; 1) 문자열 앞에서 제거할 문자(# 등)를 건너뛰기
; --------------------------------------
SkipLeading:
    mov al, [esi]
    cmp al, 0
    je  Done              ; 문자열이 전부 제거 문자였음
    cmp al, bl
    jne CopyShift         ; 첫 번째 정상 문자 발견
    inc esi               ; 다음 문자 확인
    jmp SkipLeading

; --------------------------------------
; 2) 앞부분을 제거했으므로 문자열을 앞으로 당기기
;    ESI → 앞부분 제거 후 첫 정상 문자 위치
;    EDI → 원래 문자열 시작
; --------------------------------------
CopyShift:
    mov edi, [ebp+8]

ShiftLoop:
    mov al, [esi]
    mov [edi], al
    inc esi
    inc edi
    cmp al, 0
    jne ShiftLoop

Done:
    pop edi
    pop esi
    pop ebp
    ret
Str_trim_leading_char ENDP


; ----------------------------------------------------------
; main: 테스트 코드
; ----------------------------------------------------------
main PROC
    mov edx, OFFSET msg
    call WriteString

    push '#'
    push OFFSET str1
    call Str_trim_leading_char
    add esp, 8

    mov edx, OFFSET str1
    call WriteString
    call Crlf

    exit
main ENDP
END main

------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q14.[Trimming a Set of Characters]
Create a variant of the Str_trim procedure that lets the caller remove all instances of a set of
characters from the end of a string. For example, if you were to call it with a pointer to the string
“ABC#$&” and pass it a pointer to an array of filter characters containing “%#!;$&*”, the resulting string would be “ABC”.

[해석]
문자열 끝부분에 있는 문자들 중, 호출자가 전달한 ‘제거 대상 문자 집합’에 포함된 문자라면 모두 제거하여, 마지막에 남는 정상 문자까지만 문자열을 잘라내는 Str_trim_end 함수를 만들어라.

------------------------------------------------------[Q14.code]-------------------------------------------------------------------------------------------------------

INCLUDE Irvine32.inc

.data
targetStr BYTE "ABC#$&",0
filterSet BYTE "%#!;$&*",0
msg BYTE "Result: ",0

.code

; ----------------------------------------------------------
; Str_trim_end
; Removes all ending characters that match any character in filter set.
;
; Stack parameters:
;   [ebp+8]  = pointer to string
;   [ebp+12] = pointer to filter-set string
;
; Example:
;    string = "ABC#$&"
;    filter = "%#!;$&*"
;    → result = "ABC"
; ----------------------------------------------------------

Str_trim_end PROC
    push ebp
    mov  ebp, esp
    push esi
    push edi

    mov esi, [ebp+8]      ; ESI = pointer to target string
    mov edi, [ebp+12]     ; EDI = pointer to filter set

; ----------------------------------------
; 1) 문자열 끝을 찾는다
; ----------------------------------------
FindEnd:
    mov al, [esi]
    cmp al, 0
    je FoundEnd
    inc esi
    jmp FindEnd

FoundEnd:
    dec esi               ; ESI = last character (not the null)

; ----------------------------------------
; 2) 문자열 뒤에서부터 검사하여 filter-set에 포함되어 있으면 제거
; ----------------------------------------
TrimLoop:
    cmp esi, [ebp+8]      ; 문자열 시작보다 뒤인지 확인
    jb Finish

    mov al, [esi]         ; al = 현재 검사 문자
    mov ebx, [ebp+12]     ; ebx = filter 문자 집합 시작 주소

CheckFilter:
    mov dl, [ebx]
    cmp dl, 0
    je NotFound           ; filter 끝, 일치 없음

    cmp dl, al
    je MatchFound         ; filter 문자와 일치
    inc ebx
    jmp CheckFilter

MatchFound:
    ; filter 문자에 포함 → 제거 (null로 자르기)
    mov BYTE PTR [esi], 0
    dec esi
    jmp TrimLoop          ; 다음 문자 검사

NotFound:
    ; filter에 없는 문자 → trim 종료
    jmp Finish

Finish:
    pop edi
    pop esi
    pop ebp
    ret
Str_trim_end ENDP


; ----------------------------------------------------------
; main: 테스트 실행
; ----------------------------------------------------------
main PROC
    mov edx, OFFSET msg
    call WriteString

    push OFFSET filterSet
    push OFFSET targetStr
    call Str_trim_end
    add esp, 8

    mov edx, OFFSET targetStr
    call WriteString
    call Crlf

    exit
main ENDP

END main

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
