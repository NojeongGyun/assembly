1. Converting from Big Endian to Little Endian Write a program that uses the variables below and MOV instructions to copy the value from
bigEndian to littleEndian, reversing the order of the bytes. The number’s 32-bit value is understood to be 12345678 hexadecimal.
(빅 엔디언을 리틀 엔디언으로 변환하기 아래 변수를 사용하고, MOV 명령어를 이용하여 bigEndian의 값을 littleEndian으로 복사하되, 바이트의 순서를 반대로 뒤집어라.
숫자의 32비트 값은 16진수로 12345678h이다.)

---- 1번 코드 ------------------------------------------------------------------------------------------------------------------------------------------------------
.data
bigEndian BYTE 12h,34h,56h,78h
littleEndian DWORD ?

.code
start:

    MOV AL, [bigEndian]      
    MOV [littleEndian+3], AL

    MOV AL, [bigEndian+1]    
    MOV [littleEndian+2], AL

    MOV AL, [bigEndian+2]    
    MOV [littleEndian+1], AL

    MOV AL, [bigEndian+3]    
    MOV [littleEndian], AL

    RET

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

2. Write a program with a loop and indexed addressing that exchanges every pair of values in an array with an even number of elements. Therefore, 
item i will exchange with item i+1, and item i+2 will exchange with item i+3, and so on.
(인덱스 주소 지정(indexed addressing)과 반복문(loop)을 이용하여, 요소가 짝수인 배열에서 모든 요소 쌍을 서로 교환(exchange) 하는 프로그램을 작성하라.)

---- 2번 코드 ------------------------------------------------------------------------------------------------------------------------------------------------------
.data
array BYTE 10h,20h,30h,40h,50h,60h,70h,80h 
n EQU 8

.code
start:
    MOV CX, n/2        
    XOR SI, SI        

swap_loop:
    MOV AL, [array+SI]       
    MOV BL, [array+SI+1]    
    MOV [array+SI], BL     
    MOV [array+SI+1], AL      

    ADD SI, 2              
    LOOP swap_loop            

    RET

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

3. Write a program with a loop and indexed addressing that calculates the sum of all the gaps between successive array elements. The array elements are 
doublewords, sequenced in nondecreasing order. So, for example, the array {0, 2, 5, 9, 10} has gaps of 2, 3, 4, and 1, whose sum equals 10.
(인덱스 주소 지정(indexed addressing)과 반복문(loop)을 이용하여, 배열의 연속된 요소 사이의 차이(gap)들의 합을 계산하는 프로그램을 작성하라.)

---- 3번 코드 ------------------------------------------------------------------------------------------------------------------------------------------------------
.data
array DWORD 0,2,5,9,10
n     EQU 5           
sum   DWORD 0         

.code
start:
    XOR EAX, EAX       
    XOR ESI, ESI        

    MOV ECX, n-1       

gap_loop:
    MOV EBX, [array+ESI*4]      
    MOV EDX, [array+ESI*4 + 4]  
    SUB EDX, EBX                
    ADD EAX, EDX                 

    INC ESI                      
    LOOP gap_loop

    MOV [sum], EAX              
    RET

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

4. Write a program that uses a loop to copy all the elements from an unsigned Word (16-bit) array into an unsigned doubleword (32-bit) array. 
(반복문(loop)을 이용하여 16비트 WORD 배열의 모든 요소를 32비트 DWORD 배열로 복사하는 프로그램을 작성하라.)

---- 4번 코드 ------------------------------------------------------------------------------------------------------------------------------------------------------
.data
wordArray  WORD 1000h,2000h,3000h,4000h   
n          EQU 4                           
dwordArray DWORD 4 DUP(?) 

.code
start:
    XOR ESI, ESI        ; ESI = 인덱스 (offset)
    MOV ECX, n          ; 반복 횟수 = 배열 요소 개수

copy_loop:
    MOV AX, [wordArray + ESI*2]  
    MOVZX EAX, AX                
    MOV [dwordArray + ESI*4], EAX 

    INC ESI                      
    LOOP copy_loop

    RET

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

5. Write a program that uses a loop to calculate the first seven values of the Fibonacci number sequence, described by the following formula: 
Fib(1) = 1, Fib(2) = 1, Fib(n) = Fib(n – 1) + Fib(n – 2).
(반복문(loop)을 사용하여 **피보나치 수열(Fibonacci sequence)**의 처음 7개 값을 계산하는 프로그램을 작성하라.
수열 정의: Fib(1) = 1     Fib(2) = 1     Fib(n) = Fib(n-1) + Fib(n-2), n ≥ 3)

---- 5번 코드 ------------------------------------------------------------------------------------------------------------------------------------------------------
.data
fib DWORD 7 DUP(?) 
n   EQU 7

.code
start:
    ; 초기값 설정
    MOV DWORD PTR [fib], 1       
    MOV DWORD PTR [fib+4], 1    

    MOV ECX, n-2                  
    MOV ESI, 2                  

fib_loop:
    MOV EAX, [fib + (ESI-1)*4]    
    ADD EAX, [fib + (ESI-2)*4]    
    MOV [fib + ESI*4], EAX        

    INC ESI                       
    LOOP fib_loop

    RET

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

6. Use a loop with indirect or indexed addressing to reverse the elements of an integer array in place. Do not copy the elements to any other array. 
Use the SIZEOF, TYPE, and LENGTHOF operators to make the program as flexible as possible if the array size and type should be changed in the future.
(**간접 주소 지정(indirect) 또는 인덱스 주소 지정(indexed addressing)**과 반복문(loop)을 이용하여, 정수 배열을 제자리에서 뒤집는 프로그램을 작성하라.
다른 배열로 복사하지 않고 원래 배열 자체를 변경, 배열 크기나 자료형이 바뀌어도 유연하게 만들기 위해 SIZEOF, TYPE, LENGTHOF 연산자를 사용)

---- 6번 코드 ------------------------------------------------------------------------------------------------------------------------------------------------------
.data
myArray DWORD 10, 20, 30, 40, 50, 60  

.code
start:
    MOV ESI, 0                        ; 시작 인덱스 = 0
    MOV ECX, LENGTHOF myArray / 2     ; 반복 횟수 = 배열 길이 / 2
    MOV EDI, LENGTHOF myArray - 1     ; 마지막 인덱스

reverse_loop:
    MOV EAX, [myArray + ESI*TYPE myArray]    
    MOV EBX, [myArray + EDI*TYPE myArray]
    MOV [myArray + ESI*TYPE myArray], EBX
    MOV [myArray + EDI*TYPE myArray], EAX
    INC ESI           
    DEC EDI           
    LOOP reverse_loop

    RET

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

7. Write a program with a loop and indirect addressing that copies a string from source to target, reversing the character order in the process. 
Use the following variables: source BYTE "This is the source string",0 target BYTE SIZEOF source DUP('#')
(반복문(loop)과 간접 주소 지정(indirect addressing)을 사용하여, source 문자열을 target으로 복사하되 문자 순서를 뒤집어서(reverse) 저장하는 프로그램을 작성하라.)
/* source BYTE "This is the source string",  0 target BYTE SIZEOF source DUP('#') */

---- 7번 코드 ------------------------------------------------------------------------------------------------------------------------------------------------------
.data
source BYTE "This is the source string",0
target BYTE SIZEOF source DUP('#')

.code
start:
    LEA ESI, source

find_end:
    CMP BYTE PTR [ESI], 0
    JE done_find
    INC ESI
    JMP find_end

done_find:
    DEC ESI              
    LEA EDI, target   

reverse_copy:
    MOV AL, [ESI]       
    MOV [EDI], AL      
    DEC ESI              
    INC EDI              
    CMP ESI, OFFSET source - 1  
    JG reverse_copy

    MOV BYTE PTR [EDI], 0

    RET

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

8. Using a loop and indexed addressing, write code that rotates the members of a 32-bit integer array forward one position. 
The value at the end of the array must wrap around to the first position. For example, the array [10,20,30,40] would be transformed into [40,10,20,30]. 
(반복문(loop)과 인덱스 주소 지정(indexed addressing)을 이용하여, 32비트 정수 배열을 한 칸 앞으로(Forward) 회전(rotates forward) 하는 코드를 작성하라.)
/* 배열 끝의 값은 배열 시작으로 이동의 예시 : [10,20,30,40] → [40,10,20,30] */

---- 8번 코드 ------------------------------------------------------------------------------------------------------------------------------------------------------
.data
arr DWORD 10, 20, 30, 40
n   EQU LENGTHOF arr

.code
start:
    MOV EAX, [arr + (n-1)*TYPE arr]   ; EAX = arr[n-1]

    MOV ECX, n-1                    
    MOV ESI, n-2                     
shift_loop:
    MOV EBX, [arr + ESI*TYPE arr]     ; arr[i]
    MOV [arr + (ESI+1)*TYPE arr], EBX ; arr[i+1] = arr[i]
    DEC ESI
    LOOP shift_loop

    MOV [arr], EAX

    RET

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
