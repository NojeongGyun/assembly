<pre>
- <mark>Entry point</mark> -
엔트리 포인트란 가장 처음으로 실행이 시작되는 지점으로 java에는 public static void main(String[] args)가 엔트리 포인트, c는  main()가 엔트리 포인트인데
어셈블리는 마지막 End 엔트리포인트의 변수가 있으면, 엔트리포인트 변수가 엔트리포인트가 된다.
ex) <code>
    .data
    val DWORD 5
  
    .code
    main PROC
    mov eax, val
    main ENDP
  
    test PROC
    mov eax, 10
    test ENDP
  
    <mark>END main</mark>
    </code>
- 마지막에 END main이라는 main 엔트리포인트의 변수가 있으므로  main PROC가 엔트리 포인트이다.

      
- <mark>Segment</mark>
세그먼트는 프로그램을 담는 메모리의 구역입니다. 종류는 크게 5가지로, 3장에서 나오는 세그먼트 3가지만 설명 드리겠습니다.

<b>데이터 세그먼트</b> -
데이터 세그먼트는 변수, 상수, 배열 등을 지정할 떄 사용되는 세그먼트입니다. 
사용할 떄 .data를 사용하여 그 안에 변수이름 - 저장공간 크기 - 변수에 넣을 값 ;(세미클론)   이런식으로 사용됩니다.
ex) <code>
    .data
    val1 DWORD 5 ; 
    </code>
- 변수 이름: val1, 공간: 4바이트(DWORD), 값: 5 입니다.

<b>코드 세그먼트</b> -
코드 세그먼트는 CPU가 직접 읽고 실행하는 공간으로 .data에 있는 변수들을 여기로 끌고와 레지스터와 함께 사용됩니다.
사용 할떄는 어셈블리 명령어를 필두로 보통은 나머지 2개의 값, 변수, 레지스터가 오고, 오른쪽에서 왼쪽으로 어셈블리 명령어에 따라 값이 오른쪽에서 왼쪽으로 행동 됩니다.
ex) <code>
  .code
  mov eax, val1 /* eax레지스터에 val1변수의 값을 이동(move)시킴) */
  add eax, 6 /* eax레지스터에 있는 값과 6을 더함(add) */
</code>
- 예시에서 보셨듯, 어셈블리 명령어를 먼저 사용한 후 나머지 값들이 오게 되고, 어셈블리 명령어에 의해 모든 뜻이 바뀝니다.

<b>스택 세그먼트</b> -
스택 세그먼트는 함수 호출, 지역 변수, 임시 저장용으로 사용하는 메모리 영역으로 갑을 스택에서 꺼내거나(pop) 스택에 저장(push)을 할 수 있습니다.
ex) <code>
    .stack 100h ; /* 스택 크기 256바이트 지정 */
    
    .code
    main PROC
    push eax        ; /* eax 값을 스택에 저장 */
    mov eax, 5
    pop eax         ; /* 스택에서 값 꺼내 eax에 저장 */
    ret
    main ENDP
    <code>


- <mark>Litterals</mark> -

<b>Integer Litterals</b> -   
정수 뒤에 어떤 문자를 붙이냐에 따라 진법이 바뀝니다.

<b>10진수</b> -
숫자 뒤에 아무것도 붙이지 않거나, d를 붙이면 10진수
ex) 26, 26d
      
<b>2진수</b> -
숫자 뒤에 b를 붙이면 binary
ex) 1000101b

<b>8진수</b> -
숫자 뒤에 q나 o를 붙이면 8진수
ex) 42q, 53o

<b>16진수</b> -
숫자 뒤에 h를 붙이면 16진수
ex) 1Ah, 123Bh


- <mark>연산자 우선순위</mark> -
연산자는 각 레벨을 받는데 레벨이 낮을 수록 더 늦게 연산됩니다.
() - 1Lv
+, -(부호) - 2Lv
* , /  - 3LV
MOD    - 4LV
+, -(더하기, 뺴기) - 5LV 

<b>Character Litterals</b> -
캐릭터 리터럴은 문자 1개를 의미하며, 아스키 코드를 이용하여 숫자를 캐릭터 리터럴로 변환도 가능합니다.

<b>String Litterals</b>
스트링 리터럴은 문자 1개 이상을 의미하며, 쓸때는 ' '로 뭍거나 " "로 문자열을 묶어서 만듭니다. Character랑 다른점은 마지막에 String의 끝값이 어디인지 알려주는 Null값이 포함되어있다는 점입니다.
문자열을 만들 떄 주의 사항은 첫 글자는 _(언더바)나 문자(A~Z, a~z)이여야 되고, 문자열에 특수문자를 쓰면 안된다는 점이 있습니다.


  
</pre>



, 0 - > 성공적인 마침(운영체제에 보냄)                  이외에 다른숫자로 출력되면 오류로 간주


p11 문자열을 만들때 주의 사항
p11 스택이라는 메모리를 사용하고있음 

.data, .code, .stack 100h(Segments)
Segments의 종류 암기 필수(*****)

명령의 구성(p12)
레이블 - 데이터레이블, 코드 레이블(.file에 사용함)


오퍼랜드 명령의 대상이 되는것(p13)
오퍼랜드가 1,2,3개가 될수도 있음(p13)
계산하면 데스네이션으로 들어감

Description은 사람한테 감(p16)
block comment

The nop(4바이트를 맞춰야 하기에 그 미만이 되면 부족한 만큼 아무의미 없는 내용을 추가함) p17













$사인 0,1,2 위에서 아래로 순서를 지정(p43)
