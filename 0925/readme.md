<pre>
- <mark>Entry point</mark> -
엔트리 포인트란 가장 처음으로 실행이 시작되는 지점으로 java에는 public static void main(String[] args)가 엔트리 포인트, c는  main()가 엔트리 포인트인데
어셈블리는 마지막 End 엔트리포인트의 변수가 있으면, 엔트리포인트 변수가 엔트리포인트가 된다.
ex) <code>
    .data
    val DWORD 5
  
    .code
    main PROC
    mov eax, val
    main ENDP
  
    test PROC
    mov eax, 10
    test ENDP
  
    <b>END main<b>
    </code>
- 마지막에 END main이라는 main 엔트리포인트의 변수가 있으므로  main PROC가 엔트리 포인트이다.

      
- <mark>Segment</mark>
세그먼트는 프로그램을 담는 메모리의 구역입니다. 종류는 크게 5가지로, 3장에서 나오는 세그먼트 2가지만 설명 드리겠습니다.

<b>데이터 세그먼트</b> -
데이터 세그먼트는 변수, 상수, 배열 등을 지정할 떄 사용되는 세그먼트입니다. 
사용할 떄 .data를 사용하여 그 안에 변수이름 - 저장공간 크기 - 변수에 넣을 값 ;(세미클론)   이런식으로 사용됩니다.
ex) <code>
  .data
    val1 DWORD 5 ; 
    </code>
- 변수 이름: val1, 공간: 4바이트(DWORD), 값: 5 입니다.

<b>코드 세그먼트</b> -
코드 세그먼트는 CPU가 직접 읽고 실행하는 공간으로 .data에 있는 변수들을 여기로 끌고와 레지스터와 함께 사용됩니다.
사용 할떄는 어셈블리 명령어를 필두로 보통은 나머지 2개의 값, 변수, 레지스터가 오고, 오른쪽에서 왼쪽으로 어셈블리 명령어에 따라 값이 오른쪽에서 왼쪽으로 행동 됩니다.
ex) <code>
  .code
  mov eax, val1 /* eax레지스터에 val1변수의 값을 이동(move)시킴) */
  add eax, 6 /* eax레지스터에 있는 값과 6을 더함(add) */
</code>
- 예시에서 보셨듯, 어셈블리 명령어를 먼저 사용한 후 나머지 값들이 오게 되고, 어셈블리 명령어에 의해 모든 뜻이 바뀝니다.

      
- <mark>Integer Litterals</mark> -
정수 뒤에 어떤 문자를 붙이냐에 따라 진법이 바뀝니다.

<b>10진수</b> -
숫자 뒤에 아무것도 붙이지 않거나, d를 붙이면 10진수
ex) 26, 26d
      
<b>2진수</b> -
숫자 뒤에 b를 붙이면 binary
ex) 1000101b

<b>8진수</b> -
숫자 뒤에 q나 o를 붙이면 8진수
ex) 42q, 53o

<b>16진수</b> -
숫자 뒤에 h를 붙이면 16진수
ex) 1Ah, 123Bh


  
</pre>


곱셈 연산은 eax레지스터에 저장됨
, 0 - > 성공적인 마침(운영체제에 보냄)                  이외에 다른숫자로 출력되면 오류로 간주
2진수를 활용하는 진수가 있고 아닌 진수가있음 (p5)

연산자 우선순위 p6

캐릭터는 스트링에 포함 p9 모든 스트링인 마지막엔 null(아스키코드 0)이 있다

지시어(mov, add 등) p10

p11 문자열을 만들때 주의 사항
p11 스택이라는 메모리를 사용하고있음 

.data, .code, .stack 100h(Segments)
Segments의 종류 암기 필수(*****)

명령의 구성(p12)
레이블 - 데이터레이블, 코드 레이블(.file에 사용함)


오퍼랜드 명령의 대상이 되는것(p13)
오퍼랜드가 1,2,3개가 될수도 있음(p13)
계산하면 데스네이션으로 들어감

Description은 사람한테 감(p16)
block comment

The nop(4바이트를 맞춰야 하기에 그 미만이 되면 부족한 만큼 아무의미 없는 내용을 추가함) p17













$사인 0,1,2 위에서 아래로 순서를 지정(p43)
