Q1. [Draw Text Colors]
Write a program that displays the same string in four different colors, using a loop. Call the SetTextColor procedure from the book’s link library.
Any colors may be chosen, but you may find it easiest to change the foreground color.
(동일한 문자열을 4가지 다른 색상으로 표시하는 프로그램을 작성하세요. 루프를 사용합니다. 책에서 제공하는 link library의 SetTextColor 프로시저를 호출하세요.
색상은 아무거나 선택 가능하지만, 전경색(foreground color)을 변경하는 것이 가장 쉬울 것입니다.)

------------------------------------------------------[Q1.code]-----------------------------------------------------------------------------------
.386
.model flat, stdcall
.stack 4096
include \Irvine\Irvine32.inc

.data
msg BYTE "Hello, MASM!", 0      ; 출력할 문자열
colors DWORD 4 DUP (0FFh, 0Ah, 0Ch, 0Eh) ; 글자색 (임의 지정)
index DWORD 0                   ; 루프 인덱스

.code
main PROC
    mov index, 0                ; 루프 초기화

print_loop:
    mov eax, colors[index]      ; 현재 색상
    call SetTextColor           ; 글자 색 변경
    mov edx, OFFSET msg         ; 문자열 주소
    call WriteString            ; 문자열 출력
    call CrLf                   ; 줄 바꿈

    inc index                    ; 인덱스 증가
    cmp index, 4
    jl print_loop               ; 4번 반복

    call ExitProcess
main ENDP

END main


Q2. [Linking Array Items]
Suppose you are given three data items that indicate a starting index in a list, an array of characters, and an array of link index. 
You are to write a program that traverses the links and locates the characters in their correct sequence. 
For each character you locate, copy it to a new array. Suppose you used the following sample data, and assumed the arrays use zero-based indexes:
start = 1
chars: HACEBDFG
links: 04562370
Then the values copied (in order) to the output array would be A,B,C,D,E,F,G,H. Declare the
character array as type BYTE, and to make the problem more interesting, declare the links array
type DWORD.
(링크 배열을 따라가면서 문자를 올바른 순서대로 찾는 프로그램을 작성해야 합니다. 찾은 각 문자는 새로운 배열에 복사해야 합니다.
예를 들어, 다음 샘플 데이터를 사용하고 배열이 0부터 시작하는 인덱스라고 가정하면 그러면 출력 배열에는 순서대로 A, B, C, D, E, F, G, H가 저장됩니다.
문자 배열(chars)은 BYTE 타입으로 선언하고, 문제를 조금 더 흥미롭게 만들기 위해 링크 배열(links)은 DWORD 타입으로 선언합니다.)

[Q2.code]
.386
.model flat, stdcall
.stack 4096
include \Irvine\Irvine32.inc

.data
start DWORD 1                    ; 시작 인덱스
chars BYTE 'H','A','C','E','B','D','F','G',0
links DWORD 0,4,5,6,2,3,7,0      ; 링크 배열
output BYTE 8 DUP(?)              ; 결과 저장 배열
index DWORD 0                     ; output 인덱스
current DWORD 0                   ; 현재 링크

.code
main PROC
    mov current, start            ; 시작 인덱스 저장
    mov index, 0                  ; output 인덱스 초기화

traverse_loop:
    mov eax, current              ; 현재 링크 가져오기
    movzx ebx, BYTE PTR chars[eax] ; chars[eax] 값을 ebx에 저장
    mov output[index], bl         ; output 배열에 저장
    inc index                     ; output 인덱스 증가

    mov eax, links[current*4]     ; links[current] 가져오기 (DWORD)
    mov current, eax              ; 다음 링크로 이동

    cmp index, 8                  ; 배열 크기만큼 반복
    jl traverse_loop

    ; 결과 출력
    mov edx, OFFSET output
    call WriteString
    call CrLf

    call ExitProcess
main ENDP
END main


Q3. [Simple Addition (1)]
Write a program that clears the screen, locates the cursor near the middle of the screen, prompts
the user for two integers, adds the integers, and displays their sum
(화면을 지우고, 커서를 화면 중앙 근처로 이동시키며, 사용자에게 두 개의 정수 입력을 요청하고, 두 정수를 더한 결과를 화면에 출력하는 프로그램을 작성하세요.)

[Q3.code]
.386
.model flat, stdcall
.stack 4096
include \Irvine\Irvine32.inc

.data
prompt1 BYTE "Enter first integer: ",0
prompt2 BYTE "Enter second integer: ",0
resultMsg BYTE "The sum is: ",0
num1 DWORD ?
num2 DWORD ?
sum DWORD ?

.code
main PROC
    call Clrscr                   ; 화면 지우기
    call LocateCursorMiddle       ; 커서를 중앙으로 이동

    ; 첫 번째 정수 입력
    mov edx, OFFSET prompt1
    call WriteString
    call ReadInt
    mov num1, eax

    ; 두 번째 정수 입력
    mov edx, OFFSET prompt2
    call WriteString
    call ReadInt
    mov num2, eax

    ; 두 정수 합 계산
    mov eax, num1
    add eax, num2
    mov sum, eax

    ; 결과 출력
    mov edx, OFFSET resultMsg
    call WriteString
    mov eax, sum
    call WriteDec               ; 정수 출력
    call CrLf

    call ExitProcess
main ENDP

LocateCursorMiddle PROC
    mov ah, 02h          ; 커서 위치 지정 함수
    mov bh, 0            ; 페이지 번호 0
    mov dh, 12           ; 행(Row) = 12 (약 중앙)
    mov dl, 30           ; 열(Column) = 30 (약 중앙)
    int 10h
    ret
LocateCursorMiddle ENDP

END main


Q4. [Simple Addition (2)]
Use the solution program from the preceding exercise as a starting point. Let this new program
repeat the same steps three times, using a loop. Clear the screen after each loop iteration.
(이전 연습 문제에서 작성한 프로그램을 기본으로 사용합니다. 이 새로운 프로그램은 같은 과정을 3번 반복하도록 루프를 사용합니다.
각 반복이 끝날 때마다 화면을 지웁니다.)

[Q4.code]
.386
.model flat, stdcall
.stack 4096
include \Irvine\Irvine32.inc

.data
prompt1 BYTE "Enter first integer: ",0
prompt2 BYTE "Enter second integer: ",0
resultMsg BYTE "The sum is: ",0
num1 DWORD ?
num2 DWORD ?
sum DWORD ?
counter DWORD 0

.code
main PROC
    mov counter, 0            ; 루프 카운터 초기화

repeat_loop:
    call Clrscr               ; 화면 지우기
    call LocateCursorMiddle   ; 커서 중앙 이동

    ; 첫 번째 정수 입력
    mov edx, OFFSET prompt1
    call WriteString
    call ReadInt
    mov num1, eax

    ; 두 번째 정수 입력
    mov edx, OFFSET prompt2
    call WriteString
    call ReadInt
    mov num2, eax

    ; 두 정수 합 계산
    mov eax, num1
    add eax, num2
    mov sum, eax

    ; 결과 출력
    mov edx, OFFSET resultMsg
    call WriteString
    mov eax, sum
    call WriteDec
    call CrLf

    ; 루프 카운터 증가 및 반복 조건 확인
    inc counter
    cmp counter, 3
    jl repeat_loop

    call ExitProcess
main ENDP

LocateCursorMiddle PROC
    mov ah, 02h          ; 커서 위치 지정 함수
    mov bh, 0            ; 페이지 번호 0
    mov dh, 12           ; 행(Row) = 12 (약 중앙)
    mov dl, 30           ; 열(Column) = 30 (약 중앙)
    int 10h
    ret
LocateCursorMiddle ENDP

END main


Q5. [BetterRandomRange Procedure]
The RandomRange procedure from the Irvine32 library generates a pseudorandom integer between
0 and N - 1. Your task is to create an improved version that generates an integer between M and
N - 1. Let the caller pass M in EBX and N in EAX. If we call the procedure BetterRandomRange, the
following code is a sample test:
mov ebx,-300 ; lower bound
mov eax,100 ; upper bound
call BetterRandomRange
Write a short test program that calls BetterRandomRange from a loop that repeats 50 times.
Display each randomly generated value.
(Irvine32 라이브러리의 RandomRange 프로시저는 0과 N−1 사이의 의사 난수(integer)를 생성합니다. 과제는 M과 N−1 사이의 난수를 생성하는 개선된 버전을 만드는 것입니다.
호출자는 M을 EBX, N을 EAX에 전달합니다. 예제: BetterRandomRange를 호출하면 EBX에 하한, EAX에 상한을 넣고 호출합니다. 50번 반복하는 루프에서 BetterRandomRange를 호출하고,
생성된 난수를 각각 화면에 출력하는 짧은 테스트 프로그램을 작성하세요.)

[Q5.code]
.386
.model flat, stdcall
.stack 4096
include \Irvine\Irvine32.inc

.data
count DWORD 0
maxCount DWORD 50

.code
BetterRandomRange PROC
    push ecx
    push edx

    mov edx, eax         ; edx = N
    sub edx, ebx         ; edx = N - M
    call RandomRange     ; RandomRange(0 ~ N-M-1) 반환 EAX
    add eax, ebx         ; EAX = EAX + M → 범위 M~N-1

    pop edx
    pop ecx
    ret
BetterRandomRange ENDP

main PROC
    mov count, 0

generate_loop:
    mov ebx, -300        ; 하한
    mov eax, 100         ; 상한
    call BetterRandomRange
    call WriteDec
    call CrLf

    inc count
    cmp count, maxCount
    jl generate_loop

    call ExitProcess
main ENDP

END main


Q6. [Random Strings]
Create a procedure that generates a random string of length L, containing all capital letters.
When calling the procedure, pass the value of L in EAX, and pass a pointer to an array of byte
that will hold the random string. Write a test program that calls your procedure 20 times and displays the strings in the console window. 
(모든 대문자(A~Z)로 구성된 길이 L의 난수 문자열을 생성하는 프로시저를 작성하세요. 
호출할 때: EAX에 문자열 길이 L, EDX(또는 다른 레지스터)에 난수 문자열을 저장할 배열의 주소(pointer) 전달
20번 반복하여 난수 문자열을 생성하고, 콘솔에 출력하는 테스트 프로그램을 작성하세요.)

[Q6.code]
.386
.model flat, stdcall
.stack 4096
include \Irvine\Irvine32.inc

.data
strBuffer BYTE 21 DUP(0)     ; 최대 20글자 + NULL
counter DWORD 0
maxCount DWORD 20

.code
GenerateRandomString PROC
    push ecx
    push ebx
    push edi

    mov edi, edx          ; 문자열 배열 포인터
    mov ecx, eax          ; L = 반복 횟수

gen_loop:
    call RandomRange      ; 0 ~ 25 난수
    add al, 'A'           ; 대문자로 변환
    mov [edi], al
    inc edi
    loop gen_loop

    mov byte ptr [edi], 0 ; 문자열 끝 NULL 추가

    pop edi
    pop ebx
    pop ecx
    ret
GenerateRandomString ENDP

main PROC
    mov counter, 0

test_loop:
    mov eax, 10           ; 문자열 길이 L = 10
    mov edx, OFFSET strBuffer
    call GenerateRandomString

    mov edx, OFFSET strBuffer
    call WriteString
    call CrLf

    inc counter
    cmp counter, maxCount
    jl test_loop

    call ExitProcess
main ENDP

END main


Q7 [Random Screen Locations]
Write a program that displays a single character at 100 random screen locations, using a timing
delay of 100 milliseconds. Hint: Use the GetMaxXY procedure to determine the current size of
the console window.
(100번 반복해서 화면에 한 문자를 랜덤한 위치에 출력하는 프로그램을 작성하세요. 
힌트: GetMaxXY 프로시저를 사용해서 **콘솔 화면의 현재 크기(X 최대, Y 최대)**를 알아낼 수 있습니다.)

[Q7.code]
.model flat, stdcall
.stack 4096
include \Irvine\Irvine32.inc

.data
charToShow BYTE '*',0          ; 출력할 문자
counter DWORD 0
maxCount DWORD 100
maxX DWORD ?
maxY DWORD ?
randX DWORD ?
randY DWORD ?

.code
main PROC
    call Clrscr                 ; 화면 지우기
    call GetMaxXY               ; 콘솔 크기 가져오기
    mov maxX, eax               ; 최대 X
    mov maxY, ebx               ; 최대 Y

    mov counter, 0

display_loop:
    ; 랜덤 X 좌표 (0 ~ maxX-1)
    mov eax, maxX
    call RandomRange
    mov randX, eax

    ; 랜덤 Y 좌표 (0 ~ maxY-1)
    mov eax, maxY
    call RandomRange
    mov randY, eax

    ; 커서 위치 이동 후 문자 출력
    mov dh, byte ptr randY
    mov dl, byte ptr randX
    call LocateCursor
    mov al, charToShow
    call WriteChar

    ; 100ms 지연
    mov eax, 100
    call Wait

    inc counter
    cmp counter, maxCount
    jl display_loop

    call CrLf
    call ExitProcess
main ENDP

LocateCursor PROC
    mov ah, 02h
    mov bh, 0
    int 10h
    ret
LocateCursor ENDP

END main


Q8. [Color Matrix]
Write a program that displays a single character in all possible combinations of foreground and
background colors (16  16  256). The colors are numbered from 0 to 15, so you can use a
nested loop to generate all possible combinations.
(한 문자를 256가지 색 조합(전경색 16 × 배경색 16)으로 출력하는 프로그램을 작성하세요.
색상 번호는 0~15이며, **중첩 루프(nested loop)**를 사용하여 모든 조합을 만들 수 있습니다.
즉, 흐름은 다음과 같습니다: 1.전경색(Foreground) 0~15 반복, 2.배경색(Background) 0~15 반복, 3.각 조합으로 문자 출력)

[Q8.code]
.386
.model flat, stdcall
.stack 4096
include \Irvine\Irvine32.inc

.data
ch BYTE '*',0       ; 출력할 문자
fgColor DWORD 0
bgColor DWORD 0

.code
main PROC
    call Clrscr

    mov fgColor, 0
fg_loop:
    mov bgColor, 0
bg_loop:
    ; 전경색 fgColor, 배경색 bgColor 설정
    mov eax, fgColor
    mov ebx, bgColor
    call SetColor

    ; 문자 출력
    mov al, ch
    call WriteChar

    ; 배경색 증가
    inc bgColor
    cmp bgColor, 16
    jl bg_loop

    ; 전경색 증가
    inc fgColor
    cmp fgColor, 16
    jl fg_loop

    call CrLf
    call ExitProcess
main ENDP

SetColor PROC
    push eax
    push ebx
    mov ah, 09h           ; WriteCharacterAndAttribute
    mov al, '*'           ; 출력 문자
    mov bl, al            ; 문자 아스키 (임시, 실제로 WriteChar 사용)
    mov al, 0             ; 그냥 placeholder
    ; Irvine32에서는 실제로는 SetTextColor / SetBackColor 사용 가능
    ; 예제에서는 SetTextColor를 간단히 사용
    mov eax, [esp+4]      ; foreground
    call SetTextColor
    pop ebx
    pop eax
    ret
SetColor ENDP

END main

Q9 [Recursive Procedure]
Direct recursion is the term we use when a procedure calls itself. Of course, you never want to
let a procedure keep calling itself forever, because the runtime stack would fill up. Instead, you
must limit the recursion in some way. Write a program that calls a recursive procedure. Inside
this procedure, add 1 to a counter so you can verify the number of times it executes. Run your
program with a debugger, and at the end of the program, check the counter’s value. Put a number in ECX that specifies the number of times you want to allow the recursion to continue. Using
only the LOOP instruction (and no other conditional statements from later chapters), find a way
for the recursive procedure to call itself a fixed number of times.
(ECX 레지스터에 재귀 호출을 허용할 횟수를 넣습니다. 예를 들어, ECX에 5를 넣으면 재귀가 최대 5번만 실행됩니다.
LOOP 명령어만 사용하고, 이후 장에서 배우는 조건문(JZ, JNZ, CMP 등)은 사용하지 않고, 재귀 프로시저가 정확히 지정된 횟수만큼 자기 자신을 호출하도록 구현합니다.)

[Q9.code]
.386
.model flat, stdcall
.stack 4096
include \Irvine\Irvine32.inc

.data
counter DWORD 0        ; 재귀 호출 횟수 확인

.code

Recursive PROC
    push ecx            ; 재귀 깊이 보호
    inc counter          ; 호출될 때마다 카운터 증가

    mov ecx, [esp]      ; 저장해둔 ECX 불러오기
    loop Recursive       ; LOOP 사용하여 재귀 반복

    pop ecx
    ret
Recursive ENDP

main PROC
    mov counter, 0

    mov ecx, 5           ; 재귀 허용 횟수
    call Recursive

    ; 결과 출력
    mov eax, counter
    call WriteDec
    call CrLf

    call ExitProcess
main ENDP

END main


Q10. [Fibonacci Generator]
Write a procedure that produces N values in the Fibonacci number series and stores them in an
array of doubleword. Input parameters should be a pointer to an array of doubleword, a
counter of the number of values to generate. Write a test program that calls your procedure,
passing N = 47. The first value in the array will be 1, and the last value will be 2,971,215,073.
Use the Visual Studio debugger to open and inspect the array contents.
(N개의 피보나치 수를 생성하여, DWORD(4바이트) 배열에 순서대로 저장하는 프로시저를 작성하세요. 
이 프로시저는 두 개의 입력 매개변수를 받아야 합니다. 1.DWORD 배열의 주소(pointer): 생성된 피보나치 수를 저장할 곳,
2. 생성할 피보나치 수의 개수(N)입니다. 작성한 프로시저를 테스트할 프로그램을 만들고, N = 47을 전달해서 호출하세요.
배열의 첫 번째 값은 1, 마지막 값은 2,971,215,073이 됩니다. Visual Studio의 디버거를 사용하여 배열의 내용을 열고 확인합니다.)

[Q10.code]
.386
.model flat, stdcall
.stack 4096
include \Irvine\Irvine32.inc

.data
N DWORD 47                       ; 생성할 피보나치 수 개수
fibArray DWORD 47 DUP(0)         ; 결과 배열
msg BYTE "Fibonacci sequence generated.",0

.code
GenerateFibonacci PROC
    push ebx
    push ecx
    push esi

    mov esi, edx       ; 배열 포인터
    mov ecx, eax       ; N

    cmp ecx, 0
    je fib_done        ; N=0이면 종료

    ; 첫 번째 값
    mov eax, 1
    mov [esi], eax
    inc esi
    dec ecx
    cmp ecx, 0
    je fib_done

    ; 두 번째 값
    mov eax, 1
    mov [esi], eax
    inc esi
    dec ecx
    cmp ecx, 0
    je fib_done

    ; 나머지 값들 계산
    mov ebx, 1          ; 이전 값
    mov eax, 1          ; 현재 값

fib_loop:
    add eax, ebx        ; 다음 피보나치 수 = 현재 + 이전
    mov [esi], eax
    inc esi
    mov ebx, eax
    sub ebx, eax        ; ebx = 이전 값 갱신 (잘못 계산되지 않도록)

    ; 이전 두 수를 갱신
    mov edx, [esi-4]    ; 이전 값
    mov ebx, edx        ; ebx = 이전 값
    ; eax는 현재 값 그대로

    dec ecx
    jnz fib_loop

fib_done:
    pop esi
    pop ecx
    pop ebx
    ret
GenerateFibonacci ENDP

main PROC
    mov eax, N
    mov edx, OFFSET fibArray
    call GenerateFibonacci

    ; 완료 메시지
    mov edx, OFFSET msg
    call WriteString
    call CrLf

    call ExitProcess
main ENDP

END main


Q11. [Finding Multiples of K]
In a byte array of size N, write a procedure that finds all multiples of K that are less than N. Initialize the array to all zeros at the beginning of the program, and then whenever a multiple is
found, set the corresponding array element to 1. Your procedure must save and restore any registers it modifies. Call your procedure twice, with K = 2, and again with K = 3. Let N equal to 50.
Run your program in the debugger and verify that the array values were set correctly. Note: This
procedure can be a useful tool when finding prime integers. An efficient algorithm for finding
prime numbers is known as the Sieve of Eratosthenes. You will be able to implement this algorithm when conditional statements are covered in Chapter 6.
(크기가 N인 바이트 배열에서, N보다 작은 K의 배수를 찾는 프로시저를 작성하세요. 프로그램 시작 시 배열을 모두 0으로 초기화하고, 
K의 배수를 찾으면 해당 배열 요소를 1로 설정합니다. 프로시저는 자신이 수정한 레지스터를 저장하고 복원해야 합니다.
프로시저를 두 번 호출합니다. 첫 번째: K = 2, 두 번째: K = 3, 배열 크기 N = 50 입니다. 디버거를 사용하여 배열 값이 올바르게 설정되었는지 확인합니다.

[Q11.code]
.386
.model flat, stdcall
.stack 4096
include \Irvine\Irvine32.inc

.data
N       DWORD 50
arr     BYTE 50 DUP(0)       ; 바이트 배열 초기화 0
msg     BYTE "Multiples set in array.",0

.code
FindMultiples PROC
    push eax
    push ebx
    push ecx
    push edx

    mov ecx, N          ; 0 ~ N-1 반복
    xor ebx, ebx        ; 인덱스 i = 0

find_loop:
    mov edx, ebx
    xor edx, edx
    mov dl, bl          ; i
    mov eax, [esp+16]   ; K 값
    mov edx, ebx
    mov eax, [esp+16]   ; K
    mov edx, ebx
    xor edx, edx
    mov dl, bl
    mov eax, [esp+16]
    ; i % K 계산
    mov edx, 0
    mov eax, ebx
    cdq
    div dword ptr [esp+16] ; eax / K
    cmp edx, 0
    jne skip
    mov arr[ebx], 1     ; K의 배수면 1로 설정
skip:
    inc ebx
    loop find_loop

    pop edx
    pop ecx
    pop ebx
    pop eax
    ret
FindMultiples ENDP

main PROC
    ; 배열 초기화
    mov ecx, N
    mov edi, OFFSET arr
    xor al, al
init_loop:
    stosb
    loop init_loop

    ; K=2 배수 설정
    mov eax, 2
    call FindMultiples

    ; K=3 배수 설정
    mov eax, 3
    call FindMultiples

    ; 완료 메시지
    mov edx, OFFSET msg
    call WriteString
    call CrLf

    call ExitProcess
main ENDP

END main







