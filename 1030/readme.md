<pre>
- <mark>stack</mark> -
데이터를 일시적으로 저장하는 메모리 구조이며, 마지막에 넣은 데이터가 가장 먼저 나오는(LIFO, Last In First Out) 방식으로 동작합니다.

 
<b>런타임스택</b> -
런타임 스택은 CPU 모드에 따라 크기가 달라지는 메모리 구조입니다. 이때 CPU모드란 CPU가 현재 사용하고 있는 비트 운영 방식이고, 
비트 운영 방식마다 스택 push크기가 바뀌게 됩니다.
 - 64비트 모드 -
 스택 포인터 : RSP
 push 크기   : 8바이트(스택 포인터 감소)   
 pop 크기    : 8바이트(스택 포인터 증가)   
 
 - 32비트 모드 -
 스택 포인터 : ESP
 push 크기   : 4바이트(스택 포인터 감소)
 pop 크기    : 4바이트(스택 포인터 증가)  
 
 - 16비트 모드 -
 스택 포인터 : SP
 push 크기   : 2바이트(스택 포인터 감소)
 pop 크기    : 2바이트(스택 포인터 증가)  

<b>스택 흐름</b> -
Push 명령어는 먼저 ESP || RSP || SP를 감소시키고, 소스 오퍼랜드를 스택에 복사합니다.
반대로 POP 명령어는 먼저 ESP || RSP || SP 가 가리키는 스택 요소의 내용을 해당 비트크기에 맞는 목적지 오퍼랜드에 복사 후 ESP || RSP || SP를 증가 시킵니다.

<b>push, pop 간편 명령어</b> -
PUSHFD - EFLAGS(플래그 레지스터)의 32비트 전체 값을 스택에 저장한다.
POPFD - 스택 맨 위의 32비트 값을 꺼내서 EFLAGS 레지스터에 그대로 복원한다.
 
PUSHAD - EAX → ECX → EDX → EBX → ESP(old) → EBP → ESI → EDI 순서대로 총 8개의 레지스터를 한 번에 스택에 저장하는 명령어
 (4바이트씩 저장, 따라서 총 32바이트 스택 포인터감소)
POPAD - EDI → ESI → EBP → ESP(old 제외) → EBX → EDX → ECX → EAX 순서대로 총 8개의 레지스터를 한 번에 스택에서 꺼내는 명령어
 (4바이트씩 꺼냄, 따라서 총 32바이트 스택포인터 증가)

- <mark>주소</mark> -
각 데이터는 메모리 안에서 위치를 가지며, 이 위치를 주소라고 부릅니다. 데이터의 주소를 알 수 있는 방법은 OFFSET 연산자 및 &가 있습니다.
OFFSET은 해당 데이터의 시작 주소를 알 수 있고, &는 현재 주소를 알 수 있습니다.

<b> call, jump</b> -
어셈블리에서 call이 호출 되면 다음에 실행될 주소를 스택에 저장 후, call한 데이터 주소로 jump하여 처리합니다. 데이터 주소를 처리 후 ret을 만나면 call이 호출
되었을 떄 스택에 저장된 주소를 jump를 하여 다음 주소를 처리합니다. 여기서 코드의 가독성과 편의성을 챙기기 위해 레이블(label)을 같이 사용합니다.
(ex1)







 
코드 세그먼트에 기본 주소가 들어간다

스택의 주소는 스택 세그먼트가 가지고 있음

SP = 스택의 현재 주소


p4
stack pointer by 4라면 push되면 주소값 4감소 후 데이터를 넣음, pop하면 주소값 4증가 데이터 제거

데이터를 넣고 주소를 증가시키는가? 주소를 증가시키고 데이터를 넣나? 

pop을 하면 주소에 가서 값을 Ax레지스터에 가져옴

p7
스택에 16비트/32비트 레지스터, 메모리,  imm32(임의의 데이터) 푸시 가능함

p8
pushfd - 플래그 레지스터 값을 push함
popfd - 플래그 레지스터의 값을 pop함

p9
pushad - 
popad -

p10
오른쪽 그림을 보면 ecx가 100으로 되어 있고, 반복문안에 반복문을 쓰는데 바깥의 반복문은 100번 반복하고, push를 하여 안쪽 ecx는 안쪽 반복문 20번 반복하여 둘의 ecx를 같이 사용하지 않기 위해서 push, pop을 하여 사용합니다.

p11
$ - 현재 
현재 주소 - 13바이트 - 1
그림 이해하기

p13
Destination::은 sample PROC에서 main PROC로 넘길수 있음

p15
모든 변수는 스택영역에 저장됨
call 명령 다음의 명령은 stack에 push후 ret명령을 만나면 ip레지스터

p16
그림에서 보면 00000020이 스택에 들어가있어야 더하기가 가능하다.

p17
ret을 만나면 주소 호출 후 리턴을 한다.

p19
esi, ecx가 왜 push했는지, 알고, L1 루프를 왜 하는지 왜 pop을 하는지

p23
 Using Procedures는 반복작업을 줄임
 USES esi ecx 는 esi와 ecx는 push와 pop이 자동으로 된다.

 pop하면 Destination::을 적어줘야함


</pre>






