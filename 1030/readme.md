주기억 장치 일부에 스택이 있음
RAM으로 임의로 데이터를 가져오거나 저장할 수 있음
RAM을 LIFO로 접근하면 스택을 활용하여 주소를 가져올 수 있습니다.


데이터 세그먼트는 offset가지고 주소를 알 수 있다.

코드 세그먼트에 기본 주소가 들어간다

스택의 주소는 스택 세그먼트가 가지고 있음

SP = 스택의 현재 주소


p4
stack pointer by 4라면 push되면 주소값 4감소 후 데이터를 넣음, pop하면 주소값 4증가 데이터 제거

데이터를 넣고 주소를 증가시키는가? 주소를 증가시키고 데이터를 넣나? 

pop을 하면 주소에 가서 값을 Ax레지스터에 가져옴

p7
스택에 16비트/32비트 레지스터, 메모리,  imm32(임의의 데이터) 푸시 가능함

p8
pushfd - 플래그 레지스터 값을 push함
popfd - 플래그 레지스터의 값을 pop함

p9
pushad - 
popad -

p10
오른쪽 그림을 보면 ecx가 100으로 되어 있고, 반복문안에 반복문을 쓰는데 바깥의 반복문은 100번 반복하고, push를 하여 안쪽 ecx는 안쪽 반복문 20번 반복하여 둘의 ecx를 같이 사용하지 않기 위해서 push, pop을 하여 사용합니다.

p11
$ - 현재 
현재 주소 - 13바이트 - 1
그림 이해하기

p13
Destination::은 sample PROC에서 main PROC로 넘길수 있음

p15
모든 변수는 스택영역에 저장됨
call 명령 다음의 명령은 stack에 push후 ret명령을 만나면 ip레지스터

p16
그림에서 보면 00000020이 스택에 들어가있어야 더하기가 가능하다.

p17
ret을 만나면 주소 호출 후 리턴을 한다.

p19
esi, ecx가 왜 push했는지, 알고, L1 루프를 왜 하는지 왜 pop을 하는지

p23
 Using Procedures는 반복작업을 줄임
 USES esi ecx 는 esi와 ecx는 push와 pop이 자동으로 된다.

 pop하면 Destination::을 적어줘야함









