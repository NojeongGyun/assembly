<pre>-<b>보조기억장치</b>-
보조 기억장치는 장기적으로 저장이 필요한 정보를 영구적으로 보관하는 장치입니다.실행 파일(.exe)과 라이브러리 등 필요한 자료는 모두 보조기억장치에 저장되며, 또한 사용자가 Save 명령어를 
실행하면 주기억장치에 있던 데이터가 보조기억장치에 기록됩니다. 만약 불의의 사고로 컴퓨터가 꺼지면 주기억장치의 내용은 사라지고, 비휘발성인 보조기억장치에 미리 저장된 파일과 Save로 기록된 데이터만 유지됩니다. 

-<b> 주기억장치 </b>-
주기억장치는 CPU가 프로그램을 실행하거나 데이터를 처리할 때 일시적으로 정보를 저장하고 빠르게 접근할 수 있도록 하는 휘발성 기억장치입니다. 
  
-<b> ALU </b>-
산술논리연산장치로 덧셈, 뺄셈, 곱셈, 나눗셈 같은 산술 연산과 AND, OR, NOT 같은 논리 연산을 수행하는 장치입니다. 산술논리 연산 후 레지스터에 놓고, 주기억장치로 전달합니다.
연산을 할떄에 ALU는 덧셈밖에 못하기에 -
+(덧셈) - 그냥함
-(뺄셈) - 2의 보수
/(나눗셈) - 2의 보수의 연속 빼기
*(곳셈) - 덧셈의 반복
- 이런 방법을 써서 계산합니다.

/<b> 프로그램 실행방식 </b>/
프로그램을 실행할 때는 보조기억장치에 있는 실행 파일을 주기억장치로 불러온 뒤, CPU가 명령어 단위로 레지스터에 가져와 처리해야 실행됩니다. 
덧 붙이자면 모든 동작은 레지스터에 의해 동작되고, 레지스터에 주소넣고, read 신호를 주면 메모리에 있는 주소 내용이 데이터 베이스에 저장됩니다.
보조기억장치 -> 주기억장치 -> 레지스터 

/<b> 산술 논리 후 저장방법</b>/ 
ALU로 산술 논리 연산을 한 후 레지스터에 놓고, 레지스터가 주기억장치에 연산결과를 전달합니다.

-<mark> clock </mark>-
클럭은 동기화되어 명령어를 처리하고 데이터를 전송하도록 일정한 시간 간격을 제공하는 신호입니다. cpu의 처리 속도가 빠를수록 클럭증가하는 비례형식을 가집니다. 
여러 명령어들을 수행할떄 Fetch (명령어 가져오기), Decode (해석), Execute (연산) ,Memory Access (필요 시 메모리 읽기/쓰기), Write Back (결과 저장) 순으로 수행이 됩니다.
명령어 1개의 Fetch, Decode, Execute, Memory Access, Write Back 단계는 각각 최소 1클럭 이상 소요될 수 있으며, 한 단계가 끝나야 다음 단계로 진행됩니다.
한개의 명령어를 전부 실행할떄 거치는 일련의 과정을 "명령어 사이클" 이라고 합니다.

<b>Entry Point </b>-
주기억장치에 있는 고정된 주소입니다.
 
<b>Fetch </b>-
패치란 주기억장치에 있는 엔트리 포인트 주소에서 명령어를 읽어 명령어 레지스터에 저장하고, 다음 명령어 주소를 PC에 업데이트하는 과정입니다.
  
<b>Decode </b>-
디코드란 CPU가 Fetch 단계에서 가져온 명령어를 해석하는 과정을 말합니다. 
명령어에 포함된 연산 종류(opcode), 피연산자(operand), 주소 정보 등을 분석해서 Execute 단계에서 무엇을 할지 결정합니다.
  
<b>Execute </b>-
Execute란 디코드 단계에서 해석된 명령어를 실제로 수행하는 단계를 말합니다.
산순 연산 및 논리 연산이 있으면 ALU가 수행합니다.
  
<b>Memory Access </b>-
Memory Access는 Read, write라는 두가지 신호가 있는데, 먼저 Read는 주기억장치에 계산결과를 저장하지 않고, 바로 레지스터에게 전달하고 저장하게 합니다. 
Write는 레지스터에게 전달하지 않고, 주기억장치에 계산결과를 저장합니다.
 
<b>Write Back </b>-
Execute 단계에서 계산한 결과를 최종적으로 메모리 혹은 레지스터에 저장하는 걸 말합니다. 

-<mark> Bus </mark>-
버스는 CPU, 주기억장치, 입출력 장치 등 컴퓨터 구성 요소 간에 주소, 데이터, 제어 신호를 전달하는 통로입니다. 
버스 종류에는 Control Bus (제어 버스), Address Bus (주소 버스), Data Bus (데이터 버스)가 있습니다.

<b>Control Bus </b>-
컨트롤 버스란 CPU가 데이터의 흐름과 동작을 제어하기 위해 다양한 제어 신호(읽기, 쓰기, 전송 완료 확인 등)를 전달하거나 받는 통로입니다.

<b>Adress bus </b>- 
어드레스 버스란 CPU에서 콘텐츠의 주소를 주기억장치에 보내는 통로입니다.

<b>Data bus </b>-
데이터 버스란 CPU에서 콘텐츠 주소와 같은 데이터를 주기억장치에 보내는 통로입니다.

-<b> 캐시 메모리 </b>-
CPU와 주기억장치 사이에 존재하는 메모리로써, 속도는 CPU보다 느리고, 주기억장치보다는 빠릅니다.  
CPU가 매번 느린 주기억장치에서 명령어나 데이터를 읽어오는 대신, 자주 사용하는 명령어나 데이터를 캐시에 저장해 두었다가 빠르게 꺼내올 수 있도록 합니다.

-<b> Floating point unit </b>-
Floating point unit은 부동소수점 연산을 담당하는 전용 하드웨어 장치입니다.  
기존 정수연산은 ALU로 하는데, 실수표현은 정수표현보다 최소 속도가 4배이기에, 소수를 연산할 떄는 Floating point unit 사용해 연산속도를 줄입니다.

-<b> Memory Read sequence </b>-
메모리 Read 순서는 -
1.CPU가 읽고 싶은 데이터의 주소를 주소버스(Address Bus)에 보냄
2.CPU가 Read 신호를 제어 버스(Control Bus)로 보냄
3.주기억장치가 주소 버스를 확인하고, 해당 주소에 저장된 데이터를 준비함.
4.메모리는 준비된 데이터를 데이터 버스(Data Bus)에 실어서 CPU에 전달.
5.CPU는 데이터 버스에서 데이터를 받아 레지스터에 저장.
- 입니다.
주소 지정 -> 제어 신호 전송 -> 메모리 접근 -> 데이터 전달 -> CPU수신(요약)

-<mark> 레지스터 </mark>-
레지스터는 CPU에 있는 임시기억장치입니다. 레지스터는 범용 레지스터, 특수 목적 레지스터, 상태 레지스터로 나눌 수 있습니다.

<b>범용 레지스터 </b>-
32비트 레지스터인 EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP가 있고, 다음과 같은 역할을 합니다
EAX	- 산술/논리 연산 결과 저장, 함수 반환값 저장의 역할을 하고 주로 누산기, 연산 결과, 함수 반환할 떄 사용됩니다.
EBX - 베이스(Base)	메모리 주소 계산 시 기준으로 사용되는 역할을 하고 주로 베이스, 메모리 참조할 때 사용됩니다.
ECX	- 카운터(Counter)	반복문, 루프 카운트, 문자열 명령 반복 횟수를 저장하여 주로 루프 카운터, 반복을 할 떄 사용됩니다.
EDX	- 데이터(Data)	곱셈/나눗셈 연산 보조, I/O 포트 접근을 하도록 도와주는 보조역할을 하는 레지스터입니다. 
ESI	- 소스 인덱스(Source Index)	문자열/배열 데이터 읽기 시 소스 주소 
EDI	- 목적지 인덱스(Destination Index)	문자열/배열 데이터 쓰기 시 목적지 주소
ESP	- 스택 포인터(Stack Pointer)	스택 최상단 위치를 가리킴, PUSH/POP/CALL/RET 시 사용
EBP	- 베이스 포인터(Base Pointer)	함수 호출 시 스택 프레임 기준 주소, 지역변수와 매개변수 접근
  
<b>특수 목적 레지스터 </b>-
특수 목적 레지스터는 IP, SP, BP가 있고 역할은 -
IP(Instruction Pointer): 다음에 실행할 명령어 주소 저장
SP(Stack Pointer): 현재 스택 최상단 주소
BP(Base Pointer): 스택 프레임 기준 주소
- 입니다.

<b>상태레지스터 </b>-
상태 레지스터는 ALU의 연산 이후 -
Flag - 상태를 나타내는 1비트 신호
ZF (Zero Flag) - 연산 결과가 0이면 Flag는 1이되고, 나머지는 0
SF (Sign Flag) - 결과가 음수면 1, 나머지는 0
CF (Carry Flag) - 덧셈/뺄셈 시 자리 올림/내림 발생일 때 1, 나머지는 0
OF (Overflow Flag) 부호 있는 연산에서 오버플로 발생이면 1, 나머지는 0
PF (Parity Flag) - 결과의 1 비트 개수가 짝수면 1, 나머지는 0
- 로 바뀌게 됩니다. 이 과정을 Update Status 과정이라고 하고, 결과를 통해서 조건 분기 판단, 산술 연산 판단, 논리적/제어적 활용을 합니다.
  

14p 목적에 맞게 무조권 써야하는 레지스터
몇번 반복할려고 할때(ECX)
....

15p 콘택스트 스위칭 - alt tap을 눌러 프레임을 전환 -> 메모리의 ip에 화면에 보여지는 정보를 가지고 있음

17p 연산 실행 -> status flag에 오버플로우 발생여부, 사인비트 0인지 1인지, 값이 0인지, 등 보고를 하고 신호를 보냄

18p MMX FPU충돌 - 

하위 버젼 수용하고 같은 버전 또한 수용한다 - backward compatibliity

</pre>






