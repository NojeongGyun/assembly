<pre>-<b>보조기억장치</b>-
보조 기억장치는 장기적으로 저장이 필요한 정보를 영구적으로 보관하는 장치입니다.실행 파일(.exe)과 라이브러리 등 필요한 자료는 모두 보조기억장치에 저장되며, 또한 사용자가 Save 명령어를 
실행하면 주기억장치에 있던 데이터가 보조기억장치에 기록됩니다. 만약 불의의 사고로 컴퓨터가 꺼지면 주기억장치의 내용은 사라지고, 비휘발성인 보조기억장치에 미리 저장된 파일과 Save로 기록된 데이터만 유지됩니다. 

-<b> 주기억장치 </b>-
주기억장치는 CPU가 프로그램을 실행하거나 데이터를 처리할 때 일시적으로 정보를 저장하고 빠르게 접근할 수 있도록 하는 휘발성 기억장치입니다. 

-<b> Bus </b>-
버스는 CPU, 주기억장치, 입출력 장치 등 컴퓨터 구성 요소 간에 주소, 데이터, 제어 신호를 전달하는 통로입니다. 

-<b> ALU </b> -
산술논리연산장치로 덧셈, 뺄셈, 곱셈, 나눗셈 같은 산술 연산과 AND, OR, NOT 같은 논리 연산을 수행하는 장치입니다. 산술논리 연산 후 레지스터에 놓고, 주기억장치로 전달합니다.

-<b> 프로그램 실행방식 </b>-
프로그램을 실행할 때는 보조기억장치에 있는 실행 파일을 주기억장치로 불러온 뒤, CPU가 명령어 단위로 레지스터에 가져와 처리해야 실행됩니다. 
보조기억장치 -> 주기억장치 -> 레지스터 

-<b> 산술 논리 후 저장방법</b> - 
ALU로 산술 논리 연산을 한 후 레지스터에 놓고, 레지스터가 주기억장치에 연산결과를 전달합니다.

-<mark> clock </mark>-
클럭은 동기화되어 명령어를 처리하고 데이터를 전송하도록 일정한 시간 간격을 제공하는 신호입니다. cpu의 처리 속도가 빠를수록 
여러 명령어들을 수행할떄 Fetch (명령어 가져오기), Decode (해석), Execute (연산) ,Memory Access (필요 시 메모리 읽기/쓰기), Write Back (결과 저장) 순으로 수행이 됩니다.
명령어 1개의 Fetch, Decode, Execute, Memory Access, Write Back 단계는 각각 최소 1클럭 이상 소요될 수 있으며, 한 단계가 끝나야 다음 단계로 진행되니다.
한개의 명령어를 전부 실행할떄 거치는 일련의 과정을 "명령어 사이클" 이라고 합니다.

<b>Entry Point </b>-

  
<b>Fetch </b>-

<b>Decode </b>-

<b>Execute </b>-

<b>Memory Acces </b>-

<b>Write Back </b>-


용어 : 엔티리 포인트(ip) - 1바이트씩 명령을 가져옴

하지만 패치는 1바이트의 추정이지 1바이트가 아님
패치 다음으로 하는 과정인 디코드가 패치된 명령어의 바이트 크기를 해독해줌


ex) MOV, AX, 1234h = B8 34 12 
Fatch 먼저 하는데 이 과정이 주기억장치에서 ALU로 버스를 타고 이동하여 진행함

1 -> B8
2 -> 34
3 -> 12
숫자 순으로 패치한다.


cpu는 읽는 신호, 쓰는 신호 2가지

제어신호 - 데이터가 전달되었는지 확인하는 신호(그 신호를 contoal bus가 건내줌)
Adress bus - cpu에서 콘텐츠의 주소를 주기억장치에 보내는 버스
Data bus - cpu에서 콘텐츠 주소와 같은 데이터를 주기억장치에 보내는 버스


ALU 산술 논리 연산을 한 후 레지스터에 놓고, memory에 다시 갖다 놓음
모든 계산은 ALU를 사용한다. (하지만 ALU는 덧셈밖에 못함) 
+(덧셈) - 그냥함
-(뺄셈) - 2의 보수
/(나눗셈) - 2의 보수의 연속 빼기
*(곳셈) - 덧셈의 반복


clock - input, output도 클럭 주기에 맞춰서 계산을 한다.

cpu가 빠를수록 clock이 많다

어셈블리는 PC대신 IP를 쓴다 (PC는 program count로써 주소를 나타낸다. 한 명령어가 실행되면 그 다음 주소를 가르킨다.) 

update status - 값을 변환해줌(이 과정까지가 cpu의 역할임)


java / c 의 메모리 구조
data, hip, stack영역


instruction pointer
program counter
locatin counter 
[세가지 모두 같은말]

캐시 메모리 - cpu의 속도보단 느리고, 주기억장치보단 빠르다.
cpu가 주기억장치에 내용을 꺼내오긴 보단 캐시메모리에서 명령을 가져온다
그러므로 주기억장치도 캐시메모리에 명령을 넣는다.

실수표현은 정수표현보다 최소 속도가 4배이다.
그렇기에 Floating point unit을 사용하여 속도차이를 줄인다.

모든 동작은 레지스터에 의해 동작되고, 레지스터에 주소넣고, read 신호를 주면 메모리에 있는 주소 내용이 데이터 베이스에 저장된다.(요약)

7페이지 Read sequence
보조기억장치에 exe로 된 파일을 찾고, 주기억장치에 조달 후 cpu에 읽는 신호를 보낸후 기다리면, 데이터 copy가 일어난다

protected mode - 각각의 프로세스는 보호되고 있음. ex) 액셀과 메모장은 될려고 하면 연결이 되지만 바로는 되지않음(4GB인데 64GB확장가능)

Real Adress mode - 어디든 접근 가능 
system manegement mode - 

EAX(32bit) ->  AX(16bit) -> AH(high)(8bit) - AL(Low)(8bit)

14p 목적에 맞게 무조권 써야하는 레지스터
몇번 반복할려고 할때(ECX)
....

15p 콘택스트 스위칭 - alt tap을 눌러 프레임을 전환 -> 메모리의 ip에 화면에 보여지는 정보를 가지고 있음

16p EIP JUMP(분기 점프)와 CALL은 한세트,         return과 call은 한세트?



17p 연산 실행 -> status flag에 오버플로우 발생여부, 사인비트 0인지 1인지, 값이 0인지, 등 보고를 하고 신호를 보냄

18p MMX FPU충돌 - 

지금은 fpu가 cpu안에 내장되어있음

하위 버젼 수용하고 같은 버전 또한 수용한다 - backward compatibliity

64bit버전은 이름앞에 'r'을 붙임
</pre>






