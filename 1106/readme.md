<pre>
플래그 레지스터의 값 가지고, jump 명령어를 실행 시킬 수 있다. 

p7
and논리를 사용하여 cleard(0으로 채우면)를 하면 그 비트들은 0, 그리고 unchanged(1로 채우면) 그 해당 비트들의 값이 출력됩니다.
  ex) 1001 1001 and 0000(cleard) 1111(unchanged)를 하면 상위 4비트는 0이 되고, 하위 4비트는 해당 값인 1001을 가져오게 됩니다. (and논리의 사용법) - bit mask

p8
  대문자를 소문자로, 반대로 소문자를 대문자로 바꿀려면 값에다가 -30h를 하여도 되기는하는데 and논리 연산자를 사용하면, 더 빠르게 값을 구할 수 있습니다.
  and BYTE PTR [esi],11011111b 를 하면 대문자에서 소문자로 바꿀수 있습니다.

p9
   OR연산은 0을 채우면 해당 비트를 가져오고, 1을 채우면 해당 비트를 모두 1로 만듭니다.

p10
  not을 쓰면 보수로 취할 수 있다.

p12
  @ - 익스클루시브OR             (x @ y) @ y 를 하면 x비트값이 나옵니다.
    
p13
  0 @  - unchanged
  1 @    -  보수화   (not논리연산자랑 같은 역할을 취함)

p15
  and연산자를 시행하면 Destination에 저장되어, 플래그 레지스터를 변경합니다.
  히지만 Test를 시행하면 ???
  test명령어는 and논리 연산자와 같다.
  
p16
  CMP - 비교 연산자
  if A > B, X > 0 and X < 200 등 비교 연산자를 실행시키면 CMP가 활성화된다?
    
     cmp 활용 -         플레그 레지스터인 ZF, CF를 보고 점프할지 결정함

    
  -cmp의 활용법-
    cmp reg1, reg2
    reg1 - reg2 를 연산하여, 값에 맞는 플래그 레지스터인 CF, ZF, SF, OF를 set합니다.

    cmp가 같으면 0, 크면 양수, 작으면 음수
    
~

p18
    stc - Carry flag를 1로 바꿈
    clc - Carry flag를 0으로 초기화함

p25~26 니모닉


p27 jne - Zero flag가 0일때, 점프
    je - Zero flag가 1일때 점프

  
 
  
























































  
</pre>
