<pre>
- <mark>논리 연산자 및 활용</mark> -

<b>AND</b> -
AND논리 연산자는 두 비트가 0이 하나라도 있으면 0, 모두 1이라면 1이되는 논리 연산자입니다.
AND논리 연산자를 사용하여 cleard(0으로 채움)를 하면 그 비트들은 0, 그리고 unchanged(1로 채움) 해당 비트들의 값이 출력됩니다.
활용 예시는 소문자를 대문자로 바꿀 떄 사용됩니다. 6번째 비트가 1이면 소문자, 0이면 대문자입니다.
그렇기에 소문자의 2진수 값에 AND 1101 1111 논리를 사용하면 대문자의 2진수가 나오게 됩니다.

<b>OR</b> -
OR논리 연산자는 0을 채우면 해당 비트를 가져오고, 1을 채우면 해당 비트를 모두 1로 만듭니다.
OR논리 연산자를 사용하여 unchanged(0으로 채움)을 하면 해당 비트들의 값이, set(1로채움)을 하면 해당 비트가 전부 1로 바뀌게 됩니다.  
 
<b>NOT</b> -
NOT논리 연산자는 해당 비트들을 0을 1로, 1을 0으로 변환 합니다.
NOT논리 연산자를 사용하여 해당 비트의 보수를 알 수 있습니다.

<b>XOR</b> -


p12
  @ - 익스클루시브OR             (x @ y) @ y 를 하면 x비트값이 나옵니다.
    
p13
  0 @  - unchanged
  1 @    -  보수화   (not논리연산자랑 같은 역할을 취함)

p15
  and연산자를 시행하면 Destination에 저장되어, 플래그 레지스터를 변경합니다.
  히지만 Test를 시행하면 ???
  test명령어는 and논리 연산자와 같다.
  
p16
  CMP - 비교 연산자
  if A > B, X > 0 and X < 200 등 비교 연산자를 실행시키면 CMP가 활성화된다?
    
     cmp 활용 -         플레그 레지스터인 ZF, CF를 보고 점프할지 결정함

    
  -cmp의 활용법-
    cmp reg1, reg2
    reg1 - reg2 를 연산하여, 값에 맞는 플래그 레지스터인 CF, ZF, SF, OF를 set합니다.

    cmp가 같으면 0, 크면 양수, 작으면 음수
    
~

p18
    stc - Carry flag를 1로 바꿈
    clc - Carry flag를 0으로 초기화함

p25~26 니모닉


p27 
    -!cmp와 sub차이점 알기!-
    
    jne - Zero flag가 0일때, 점프
    je - Zero flag가 1일때 점프

    니모닉 단축어?
    jg = jnle 
    jl - jnge

p31(test예제)
    test - 
    
 ~~~~~~ 

p41
  Loop

~~~~

p55
  table에 관한 예제

p59
  어셈블리 언어의 반복문 

























































  
</pre>
